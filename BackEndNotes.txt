Back End:

Node fundamentals

Express lib

//////////////////////////////////////////////////////////////////////////////////////////

What is node?

 node js is non blocking /Async io platform, to run javascript application.


What is non blocking /async programming?

Concurrency : 

1.process level multi threading
2.process level single threading  ; event loop /worker thread model.

node has been built to write io applications(network) applications without process level mutli threading. rather than kernal level threads.

Async programming is nothing but , tasks are executed by os kernal, results are handled by node runtime.

Async programming implmentations:

1.you need to pass function as parameter - handler function/ callback function

2.that function must be mapped with high level javascript/node async apis


how to know the program is async or not?

1.you need to know node and js async api

timers - settimeout,setinterval,setImmedate
io  - read,write, files
network - http,tcp related apis
...........refer node api docs.


Styles of async  programming:

1.callback style : core style
2.Promises
3.async await
//////////////////////////////////////////////////////////////////////////////////////////
Writing async programming:

1.callbacks

//callback based async programming: 
//timer api

function task(whatTask) {
    console.log(`${whatTask} Async task`)
}
console.log('start')
setTimeout(task, 1000, 'WebServer');
console.log('end')
//
function startHttpServer(callback) {
    setTimeout(callback, 2000);
}
startHttpServer(function () {
    console.log('Http Server is listening!')
})
/////////////////////////////////////////**********/////////////////////////////////////


//complex callback programming

//resolve = success
//reject =failure
const getUser = (resolve, reject) => {

    //biz logic
    let user = {
        id: 1,
        name: 'Subramanian'
    };
    //let user = null;
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, { code: 501, message: 'User not found!!' })
    }

}

getUser(response => console.log(response), err => console.log(err));
///////////////////////////////////////////////////////////////////////////////////////////

Callback hell && Nesting callbacks

It is not compile time or run time error.
It is way of writing callback based programming.

The output of one callback will be input to another callback.


//callback nesting && callback hell

const getUser = (resolve, reject) => {
    //biz logic
    let user = {
        id: 1,
        name: 'Subramanian'
    };
    //let user = null;
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, { code: 501, message: 'User not found!!' })
    }

}

const login = (user, resolve, reject) => {

    //biz logic
    if (user.name === 'Subramanian') {
        setTimeout(resolve, 1000, { code: 200, message: 'Login successfull' })
    } else {
        setTimeout(reject, 1000, { code: 501, message: 'Login failed!' })
    }
}

const isPremiumUser = (status, resolve, reject) => {

    if (status.code === 200) {
        setTimeout(resolve, 1000, { code: 200, message: 'Premium User' })
    } else {
        setTimeout(reject, 1000, { code: 501, message: 'Guest User' })
    }
}



getUser(user => {
    console.log('getting user....')
    login(user, status => {
        console.log('start authentication.....')
        isPremiumUser(status,
            usertype => console.log(usertype),
            err => console.log(err))
    }, err => console.log(err))
}, err => console.log(err));


look at the above function call, ask your self

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

  "No" : This is what we call as "Callback hell"

Callback hell is not error, but way of writing async programming using nested callback.


fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})


How to write better callback programming? or How to avoid callback hell?

Solution : One Design pattern is 


In 2005, JQUERY team started with working complex callback patterns, they found callback
hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "promise".


Promise is design pattern which hides complexity of callback patterns.

SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks



Because of popularty of this design among javascript developers, ECMA 6 Committee introduced
"promise design pattern in ES6 as Promise"

Promise Object is reference implementation of "promise design pattern".


ES 6 promise Implementation:

Promise Object.

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms.

2.Promise can be used with any async implementations.

Promise Object can be created in two ways 

1.Using factory apis
2.Using Constructor patterns

1. Create Promise Object from Promise contructor
        new Promise()
2. Create Promise object from factory apis
   ClassName.getInstance()===Object
	Promise.resolve() ==>Promise
        Promise.reject() ===>Promise

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
4.resolve
5.reject
6.all
7.race


const getUser = () => {
    let user = {
        id: 1,
        name: 'Subramanian'
    }
    if (user) {
        return Promise.resolve(user);
    } else {
        return Promise.reject({ code: 500, message: 'User not Found!' })
    }
}

// const promise = getUser()
// promise.then(user => console.log(user));
// promise.catch(err => console.log(err));

//command chain
getUser()
    .then(user => console.log(user))
    .catch(err => console.log(err));

//////////////////////////////////////////////////////////////////////////////////////////////
Promise constructor Pattern:

//how to write existing callbacks with promise implementation.
//how to wrap with timeout with more ms.

const getUser = () => {
    let user = {
        id: 1,
        name: 'Subramanian'
    }
    //with constructor pattern
    return new Promise((resolve, reject) => {

        if (user) {
            setTimeout(resolve, 5000, user);
        } else {
            setTimeout(reject, 1000, { code: 500, message: 'User Not Found!!' })
        }
    });

}
getUser()
    .then(user => console.log(user))
    .catch(err => console.log(err))
    .finally(() => {
        console.log('done!!!')
    })

////////////////////////////////////////////////////////////////////////////////////////////

How to refactor callback hell/ callback nesting?


//callback nesting && callback hell =>promise conversion

const getUser = () => {
    //biz logic
    let user = {
        id: 1,
        name: 'Subramanian'
    };
    //let user = null;
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { code: 501, message: 'User not found!!' })
        }
    })


}

const login = user => {
    //biz logic
    return new Promise((resolve, reject) => {
        if (user.name === 'Subramanian') {
            setTimeout(resolve, 1000, { code: 200, message: 'Login successfull' })
        } else {
            setTimeout(reject, 1000, { code: 501, message: 'Login failed!' })
        }
    })

}

const isPremiumUser = status => {

    return new Promise((resolve, reject) => {
        if (status.code === 200) {
            setTimeout(resolve, 1000, { code: 200, message: 'Premium User' })
        } else {
            setTimeout(reject, 1000, { code: 501, message: 'Guest User' })
        }
    });

}



// getUser(user => {
//     console.log('getting user....')
//     login(user, status => {
//         console.log('start authentication.....')
//         isPremiumUser(status,
//             usertype => console.log(usertype),
//             err => console.log(err))
//     }, err => console.log(err))
// }, err => console.log(err));

//Promise Powered
getUser()
    .then(user => {
        console.log('getting user....')

        return login(user) // return new Promise
    }
    )
    .then(status => {
        console.log('start authentication.....')
        return isPremiumUser(status) // return new Promise
    }
    )
    .then(usertype => {
        console.log('Welcome to My Site.....')
        console.log(usertype)
    })
    .catch(err => console.log(err))
    .finally(() => console.log('done!!'))

////////////////////////////////////////////////////////////////////////////////////////

Promise Hell:
............

How to solve promise?


if you handle promises with nested way, it also creates complexity, this is called promise hell.

we are going to use promise but we are going to simplify promise handling.

getUser()
    .then(user => login(user))//returns promise
    .then(status => showPage(status)) //returns Promise
    .then(log)
    .catch(log)
    .finally(() => console.log('Program is terminted'))


How we can remove this code? 

async and await keywords

async is keyword used in front function : async functions


//async and await keywords
/**
 * async function by default returns Promise.resolve
 */
//normal function
function getName() {
    return 'Subramanian'; //now return type is string
}
console.log(getName());
//async function : by default return promise
async function getValue() {
    return 100; // Promise.resolve(100)
}
getValue().then(value => console.log(value));

//async function and Promsise
async function getStock() {
    return Promise.reject(1000)// Promise.resolve(100)
}
getStock().then(value => console.log(value));
///////////////////////////////////////////////////////////////////////////////////////////

Objective : async function is to remove then and catch blocks

Steps:

1.function which returns values, must have been wrapped by Promise Object

2.function which calls(Caller), must use async keyword and await keyword is used to resolve
 /reject promises without using then and catch..




//async and await keywords

//callee
function getUser() {
    let user = {
        id: 1,
        name: 'Subramanian'
    };
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { code: 501, message: 'User not found!!' })
        }
    })
}

const login = user => {
    //biz logic
    return new Promise((resolve, reject) => {
        if (user.name === 'Subramanian') {
            setTimeout(resolve, 1000, { code: 200, message: 'Login successfull' })
        } else {
            setTimeout(reject, 1000, { code: 501, message: 'Login failed!' })
        }
    })

}

const isPremiumUser = status => {

    return new Promise((resolve, reject) => {
        if (status.code === 200) {
            setTimeout(resolve, 1000, { code: 200, message: 'Premium User' })
        } else {
            setTimeout(reject, 1000, { code: 501, message: 'Guest User' })
        }
    });

}
//caller using then ables
// function fetchUser() {
//     getUser()
//         .then(user => console.log(user))
//         .catch(err => console.log(err))
//         .finally(() => console.log('Done!!!'))

// getUser()
//     .then(user => {
//         console.log('getting user....')
//         return login(user) // return new Promise
//     }
//     )
//     .then(status => {
//         console.log('start authentication.....')
//         return isPremiumUser(status) // return new Promise
//     }
//     )
//     .then(usertype => {
//         console.log('Welcome to My Site.....')
//         console.log(usertype)
//     })
//     .catch(err => console.log(err))
//     .finally(() => console.log('done!!'))
// }
//caller using async
async function fetchUser() {

    try {
        const user = await getUser();
        console.log('getting user....')
        const status = await login(user);
        console.log('start authentication.....')
        const usertype = await isPremiumUser(status);
        console.log('Welcome to My Site.....');
        console.log(usertype)
    }
    catch (err) {
        console.log(err)
    } finally {
        console.log('Done!!!!')
    }

}
fetchUser()
//////////////////////////////////////////////////////////////////////////////////////////

node moduarity;

common js:

commonjs -cjs is design pattern , already implemented in node application.
//////////////////////////////////////////////////////////////////////////////////////////////

import,export,export default - es 6 modules

require,      exports,module.exports
 |              |        |
function       variables to hold the code

exports pack code inside object
module.exports packs code as it is.


/////////////////////////////////////////////////////////////////////////////////////////


const TODOS = require('../mockdata/TODOS');

class TodoService {
    constructor() {

    }
    findAllTodos() {
        return TODOS;
    }
}
module.exports = TodoService;

//import mylib
const { name, city, state, isValid, ranking, sayGreet, skills } = require('./mylib');
const TodoService = require('./services/TODOService');

console.log(name, city, state)

// const todoService = new TodoService();
// console.log(todoService.findAllTodos());

const { findAllTodos } = new TodoService();
console.log(findAllTodos());

//////////////////////////////////////////////////////////////////////////////////////////

const TODOS = require('../mockdata/TODOS');

class TodoService {
    constructor() {

    }
    //sync api
    findAllTodos() {
        return TODOS;
    }
    //async code :callback
    findAllTodosUsingCB(resolve, reject) {
        //timer
        setTimeout(resolve, 1000, TODOS);
    }
    //async code : promise
    findAllTodosUsingPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, TODOS);
        });
    }
}
module.exports = TodoService;

//import mylib
const { name, city, state, isValid, ranking, sayGreet, skills } = require('./mylib');
const TodoService = require('./services/TODOService');

console.log(name, city, state)

// const todoService = new TodoService();
// console.log(todoService.findAllTodos());

const { findAllTodos, findAllTodosUsingCB, findAllTodosUsingPromise } = new TodoService();
//sync api calls
//console.log(findAllTodos());

//make async calls : using callbacks
//findAllTodosUsingCB(todos => console.log(todos));
async function fetchTodos() {
    // findAllTodosUsingPromise()
    //     .then(todos => console.log(todos))
    //     .catch(err => console.log)
    try {

        const todos = await findAllTodosUsingPromise();
        console.log(todos);
    } catch (err) {

    }
    finally {
        console.log('done!!')
    }
}
fetchTodos();
********************************************************************************************
node in built objects

All javascript objects except dom objects.

NODE REPL ; 


Node global object

process : Process
Represents running node process(runtime)

browser global object

window.
/////////////////////////////////////////////////////////////////////////////////////////////

Node Modules:

1.custom module  : module built by developers
   eg TodoService 
2.built in modules
   modules are provided by node.
 core modules for building non blocking io and network applications

3.thrid party modules
   this is module provided by community.
   
note:

 any module, which is simple javascript file, which has code

built in modules:

1.os --->os.js

const TODOS = require('../mockdata/TODOS');
const os = require('os');

in the above example one require uses ../ others no.


if no ./ means, node will search 'os.js' from the following order.


   Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built installtion folder---c:/pf/node/node_nodules--if it finds it will pick up from there else it will throw error.

Error: Cannot find module 'osxxx'
Require stack:
- C:\session\evergent\mynode-app\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\evergent\mynode-app\src\index.js:2:18)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\evergent\\mynode-app\\src\\index.js'[39m ]
}
///////////////////////////////////////////////////////////////////////////////////////////
EventEmitter: How to write event driven programming.

 It is used to build driven programming.
 In node js most io applications are event driven.

Here we are going to talk how to write custom events.


//custom events
const EventEmitter = require('events')

//create EventEmitter
const event = new EventEmitter();

//subscribers
//on(nameofthevent,listener)
event.on('hello', function (evt) {
    console.log(evt);
});

//publisher
//send event,subcribers are notified
event.emit('hello', 'Hello Node');

//////////////////////////////////////////////////////////////////////////

//how to attache events to objects

class MessageService extends EventEmitter {
    constructor() {
        super();
        this.on('ondata', function (data) {
            console.log(data);
        });
        this.on('onerror', function (err) {
            console.log(err);
        });
    }
    sendMessage(message) {
        if (message) {
            this.emit('ondata', message)
        } else {
            this.emit('onerror', 'Something Went Wrong!!!!');
        }
    }
}
let service = new MessageService();
service.sendMessage('Product Received!');
service.sendMessage();
********************************************************************************************

Async Programming in IO: Non blocking IO:

IO : INPUT AND OUTPUT =>READ AND WRITE

int a =10; //in memory : write : writing 10 value into a'address
log a =>read

IO is every where.

IN general all pl, uses blocking/sync mode of reading and writing.
in java, java creates a thread to read or write
 web programming , tomcat creates thread to handle request-response -(io)
         request -- read
         response - write
where as non blocking arch(nodejs,vertx), to read and write ,done by os kernal threads.



Node non blocking io apis

1.fs io
   -files system 
2.network io
  -http : web apps
  -tcp
  -udp

//non blocking io
const fs = require('fs');

//read file in non blocking mode
let filePath = './src/assets/info.txt'
const config = {
    encoding: 'UTF-8'
}
console.log('start')
//read file ; async way
fs.readFile(filePath, config, function (err, data) {
    if (err) throw err;
    console.log(data);
});
console.log('end')

//write data into file
filePath = './src/assets/info-copy.txt'
let data = 'How do I start with Node.js after I installed it?'

fs.writeFile(filePath, data, function (err) {
    if (err) throw err;
    console.log('file has been written succefully')
});

////////////////////////////////////////////////////////////////////////////////////////////

1.__dirname
      ->Get current dir path
2.__filename
     ->Get current dir + path__filename
     ->Get current dir + path

path module
The path module provides utilities for working with file and directory paths in platform
independant way.

const fs = require('fs');
const path = require('path');

const fs = require('fs');
const path = require('path');

let filePath = path.join(__dirname, '../assets/info.txt');
const config = {
    encoding: 'UTF-8'
}
class FileService {
    constructor() {

    }
    //callback based
    // readFile(resolve, reject) {
    //     fs.readFile(filePath, config, function (err, data) {
    //         if (err) {
    //             reject(err)
    //         }
    //         resolve(data);
    //     });
    // }
    //promise based
    readFile() {
        return new Promise((resolve, reject) => {
            fs.readFile(filePath, config, function (err, data) {
                if (err) {
                    reject(err)
                }
                resolve(data);
            });
        })

    }
    writeFile() {
        //TODO:YOURSELF
    }
}

module.exports = new FileService()



//file opeations
//front end program

const { readFile, WriteFile } = require('./services/FileService');

async function fetchFile() {
    // readFile(function (data) {
    //     console.log(data)
    // }, function (err) {
    //     console.log(err);
    // })
    try {

        const content = await readFile();
        console.log(content);
    } catch (err) {
        console.log(err);
    }
    finally {
        console.log('File Operation done!!')
    }

}
fetchFile();
/////////////////////////////////////////////////////////////////////////////////////////////

Sync read files:
................


const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}

console.log('start');
const data = fs.readFileSync(filePath, config);
console.log(data);
console.log('end')
///////////////////////////////////////////////////////////////////////////////////////////

Streaming:
.........
Async io operations can be done two ways.

1.Non-Streaming
2.Streaming  : Evented IO : Event driven IO.

Non Streaming IO : read / write

non streaming vs streaming:

The operating system completes the whole file read operation, sends to node process memory  , and finally will be delivered to user
  if more files , then process will be halt.

Non streaming apis are not suitable for network concurrent file operations.

What is the solution?

Streaming

Packet===breaking content into smaller units each unit is called packet.

node breaks content into smaller unit called "chunk"
node streams /send data in order chunk by chunk.



Types of Streams:

1.Readaable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output


Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin

Writable Streams:

HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr

All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.



//streaming
const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}

//create inputstream
const inputstream = fs.createReadStream(filePath, config);

//streaming apis are event driven
let data = ''
inputstream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
});
inputstream.on('end', function () {
    console.log('end : no more data to read')
    console.log(data);
});
inputstream.on('close', function () {
    console.log('file has been closed')
});
inputstream.on('error', function (err) {
    console.log(err);
});
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');
const config = {
    encoding: 'utf8',
    flag: 'w'
};
const grains = ['wheat', 'rice', 'oats'];

const outputStream = fs.createWriteStream(fileName, config);

while (grains.length) {
    let data = grains.pop() + " ";
    outputStream.write(data);
    console.log("Wrote: %s", data);
}
outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
});
////////////////////////////////////////////////////////////////////////////////////////////

Back pressure:

Problems when you do read and write together

1. In general read operation is faster than write operation

Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


Handling back pressure:
.......................
Pause Input stream if the Node Process memory is full(Buffer),resume if buffer/process memory is empty.

stream.pause() if stream is full
else
stream.resume() if stream is drain

//back pressure:
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/big_copy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);

    let buffer_good = writeStr.write(chunk);

    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});

readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});



const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, '/assets/big.file');
const outputfileName = path.join(__dirname, '/assets/big_copy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
///////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////

network programming : web programming ; http

http module
//node - we create web server, web app, and we deploy 
const http = require('http');
//http is duplex streaming module : read(request) and write(reponse)
//in http every thing is object, which are created alredy , just we are using
//http since stream, which has lot events.

//networking : http
const http = require('http');

//non blocking web servers and web apps

//create server

const server = http.createServer(function (req, res) {
    //handle request and response
    res.write('<h1>Hello Node Web App</h1>');
    //close the stream
    res.end();

});

//start server
server.listen(3000, function () {
    console.log('Server listens')
});

//server events
server.on('request', function (req, res) {
    console.log(`${req.url} - ${req.method}`)
});
/////////////////////////////////////////////////////////////////////////////////////////////

//How to send data?

JSON data.
const TODOService = require('./services/TODOService');
const { createServer } = require('http');

const { findAllTodosUsingPromise } = new TODOService();
//todo app : Controller
const server = createServer(async (req, res) => {

    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    try {
        const todos = await findAllTodosUsingPromise();
        res.write(JSON.stringify(todos));
    }
    catch (err) {
        res.write(JSON.stringify(err));
    }
    res.end();

});

server.listen(3000, function () {
    console.log('Server is Ready!');
});

/////////////////////////////////////////////////////////////////////////////////////////////

Can i build real time web apps using http module alone?

Yes, but very complex:

complexity in the core http module:
...................................

1.url and method /api/todos -GET ,POST,
2.No proper modularity.

Developer only has to focus application logics only.

Solution:

frameworks and libs

frameworks : express js

What is express js?
 express js is a very small framework built by node core team, even first framework on node
on http core module.

express js is used to build web applications and web services.

how to start working with express js?

Third party node modules.

/////////////////////////////////////////////////////////////////////////////////////////////


npm: node package manager :  
  tool used to publish,install,manage node modules provided by thrid parties.

npm repositry : npmjs.com /org

provider
  Who publish node modules into npmjs registry
consumer
  who consumes/installs node modules into their projects.

according to npm, every javascript project must have one file called "package.json"

package.json project meta file.

create package.json file

$npm init

{
  "name": "mynode-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}

how to install, uninstall packages?
node_modules folder where all thrid party modules are installed.

npm command 

npm install(i) modulename --options

--options

--save
--save-dev
--production
-g

modules can be dived into three categaory

1.only development
  eg: testing
2.development and production
  eg : react
3.tooling - only development
  webservers,compilers.....

 options can help us to divide modules according to use case.



--save; is optional 

eg:
 npm install module name
 npm install module name --save

 npm i  lodash --save

2.development and production
"dependencies": {
    "lodash": "^4.17.15"
  }

uninstall
npm uninstall lodash --save
//////////////////////////////////////////////////////////////////////////////////////////////

Development modules && tools:

Testing: unit testing

"devDependencies": {
    "chai": "^4.2.0"
  }


Testing common concepts:

1.assertion libs
2.test runtime

                                      
                                       assertions(chai,React Testing Library,Enzyme)
					     |
				       Test Runtime -(mocha,jasmin,jest,Karama,Protractor)
					    |
                                        Node -Runtime

mocha is tool.

mocha can be installed to run chai assertions

mocha tool is available as global.: not installed in the local project, available like
shellscripts,bat files windows.

C:\Users\sasub\AppData\Roaming\npm\mocha
////////////////////////////////////////////////////////////////////////////////////////////

Drawbacks of global modules:
............................

1.version mismatch across multi projects

Solution :

install global modules as local modules(--save-dev module)


>npm install mocha --save-dev


how to run mocha now?

 >mocha

'mocha' is not recognized as an internal or external command,
operable program or batch file

why? you can access only global modules like above

then how to use?

"scripts" :

 is used for automation.

"command" : "task to be excuted"

npm provides lot of built in commaands

 -test,start,....

 "scripts": {
    "test": "mocha"
  }

how to run this?

 "scripts": {
    "test": "mocha",
     "start" : "node src/index.js"
  }
 
 npm test
 npm start

scripts command even can be custom commands

 "subu" : "node src/index.js"

how to run this?

 npm run subu

//////////////////////////////////////////////////////////////////////////////////////////


webpack:

For build process
 -compilation ; es6 to es5
 
npm i webpack webpack-cli --save-dev

const path = require('path');

module.exports = {
    entry: './src/index.js',
    mode: 'production',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    }
};

  "scripts": {
    "test": "mocha",
    "start": "node src/index.js",
    "subu": "node src/index.js",
    "build": "webpack --watch"
  },
//////////////////////////////////////////////////////////////////////////////////////////////

Express application:
...................

install express framework

start creating rest end points

Rest points;


URL ,METHODS

Express core concepts:

In express every object is object

1.Application object
2.request object
3.response object
4.router object

1.Application object
  container object , which contains other objects

create application object

start create rest end points.


//express application
const express = require('express') // returns a function, used to create application object

//create application object
const app = express();


//rest end points
//home page
app.get('/', (req, res) => {
    res.send('<h1>Evergent REST API Server</h1>')
});

//todos
app.get('/api/todos/list', (req, res) => {
    res.send('todos -list')
})

app.post('/api/todos', (req, res) => {
    res.send('todos -post')
})

app.put('/api/todos', (req, res) => {
    res.send('todos -put')
})

app.delete('/api/todos', (req, res) => {
    res.send('todos -delete')
})
//to start and listen server

app.listen(3000, function () {
    console.log('Express server is ready!!!');
});

adding with node monitor; nodemon

"scripts": {
    "start": "nodemon src/app.js"
  }

const TODOS = require('../mockdata/TODOS');

class TodoService {
    constructor() { }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, TODOS);
        });
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            const filteredTodo = TODOS.filter((todo, index) => {
                return todo.id === parseInt(id);
            })
            if (filteredTodo && filteredTodo.length > 0) {
                resolve(filteredTodo)
            } else {
                reject({ message: 'No todo' })
            }
        });
    }
}
module.exports = new TodoService();

//express application
const express = require('express') // returns a function, used to create application object
const { findAll, findById } = require('./services/TODOService');

//create application object
const app = express();


//rest end points
//home page
app.get('/', (req, res) => {
    res.send('<h1>Evergent REST API Server</h1>')
});

//todos : controller
app.get('/api/todos/list', async (req, res) => {

    try {
        const todos = await findAll();
        res.json(todos);
    }
    catch (err) {
        res.json(err);
    }

})

// /api/todos/1
app.get('/api/todos/:id', async (req, res) => {
    const id = req.params.id;
    try {
        const todos = await findById(id);
        res.json(todos);
    }
    catch (err) {
        res.json(err);
    }

})

app.post('/api/todos', (req, res) => {
    res.send('todos -post')
})

app.put('/api/todos', (req, res) => {
    res.send('todos -put')
})

app.delete('/api/todos', (req, res) => {
    res.send('todos -delete')
})
//to start and listen server

app.listen(3000, function () {
    console.log('Express server is ready!!!');
});
///////////////////////////////////////////////////////////////////////////////////////////

How to build modular domain driven apis?

domains 
todos   customer users  product .................


/api/todos
 GET
 POST
 DELETE
 PUT

/api/customer
 GET
 POST
 DELETE
 PUT

/api/users
 GET
 POST
 DELETE
 PUT

/api/products
 GET
 POST
 DELETE
 PUT
//////////////////////////////////////////////////////////////////////////////////////////////

                                           (Domain Controller)         Service Layer             Data
											        Source			

                                            |----UserController   <--->  UserService <-->    Mongo/mssql/oracle/third party end point
       /api/users                           |   (GET,POST,DELETE)
View---/api/todos----http--|GateWay Router--|----TODOSController 
       /api/products       (app.js)         |   (GET,POST,DELETE)
                                            |----ProductController
						 (GET,POST,DELETE)



Gateway is other wise called as "Front Controller"



services

const TODOS = require('../mockdata/TODOS');

class TodoService {
    constructor() { }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, TODOS);
        });
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            const filteredTodo = TODOS.filter((todo, index) => {
                return todo.id === parseInt(id);
            })
            if (filteredTodo && filteredTodo.length > 0) {
                resolve(filteredTodo)
            } else {
                reject({ message: 'No todo' })
            }
        });
    }
}
module.exports = new TodoService();

const USERS = require('../mockdata/Users');

class UserService {
    constructor() { }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, USERS);
        });
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            const filteredUser = USERS.filter((user, index) => {
                return user.id === parseInt(id);
            })
            if (filteredUser && filteredUser.length > 0) {
                resolve(filteredUser)
            } else {
                reject({ message: 'No Users' })
            }
        });
    }
}
module.exports = new UserService();


const TODOS = require('../mockdata/TODOS');

class TodoService {
    constructor() { }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, TODOS);
        });
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            const filteredTodo = TODOS.filter((todo, index) => {
                return todo.id === parseInt(id);
            })
            if (filteredTodo && filteredTodo.length > 0) {
                resolve(filteredTodo)
            } else {
                reject({ message: 'No todo' })
            }
        });
    }
}
module.exports = new TodoService();

Controllers:
const express = require('express');
const { findAll, findById } = require('../services/TODOService');


//create router object
const todocontroller = express.Router();


//todos : controller
todocontroller.get('/list', async (req, res) => {

    try {
        const todos = await findAll();
        res.json(todos);
    }
    catch (err) {
        res.json(err);
    }

})

// /api/todos/1
todocontroller.get('/:id', async (req, res) => {
    const id = req.params.id;
    try {
        const todos = await findById(id);
        res.json(todos);
    }
    catch (err) {
        res.json(err);
    }

})

todocontroller.post('/', (req, res) => {
    res.send('todos -post')
})

todocontroller.put('/:id', (req, res) => {
    res.send('todos -put')
})

todocontroller.delete('/:id', (req, res) => {
    res.send('todos -delete')
})

//exports controller
module.exports = todocontroller;

/////////////////////////////////////////////////////////////////////////////////////////////

const express = require('express');
const { findAll, findById } = require('../services/UserService');


//create router object
const usercontroller = express.Router();


//todos : controller
usercontroller.get('/list', async (req, res) => {

    try {
        const users = await findAll();
        res.json(users);
    }
    catch (err) {
        res.json(err);
    }

})

// /api/todos/1
usercontroller.get('/:id', async (req, res) => {
    const id = req.params.id;
    try {
        const todos = await findById(id);
        res.json(users);
    }
    catch (err) {
        res.json(err);
    }

})

usercontroller.post('/', (req, res) => {
    res.send('users -post')
})

usercontroller.put('/:id', (req, res) => {
    res.send('users -put')
})

usercontroller.delete('/:id', (req, res) => {
    res.send('users -delete')
})

//exports controller
module.exports = usercontroller;

//express application
const express = require('express') // returns a function, used to create application object
const TodoController = require('./controllers/todocontroller');
const UserController = require('./controllers/userscontroller')

//create application object
const app = express();

// /api/todos/list : redirect to the TODOS Controller.
app.use('/api/todos', TodoController)
// /api/users/list : redirect to the USERS Controller
app.use('/api/users', UserController)



//rest end points
//home page
app.get('/', (req, res) => {
    res.send('<h1>Evergent REST API Server</h1>')
});


//to start and listen server
app.listen(3000, function () {
    console.log('Express server is ready!!!');
});

////////////////////////////////////////////////////////////////////////////////////////////

how to send data : post,put ;
...........................

todocontroller.post('/', async (req, res) => {

    try {
        const todos = await findAll();

        //how to read read.
        //attach data event to read data
        let data = '';
        req.on('data', (chunk) => {
            //read request pay load
            //console.log(chunk.length)
            data += chunk;
        });
        //attach end event to ensure , data read operation is completed and then send response
        req.on('end', () => {
            console.log(data);
            res.json(todos.concat(JSON.parse(data)));
        });


    }
    catch (err) {
        res.json(err);
    }

})
middlewares:
............

express application is growing based on middlewares(plugins)

for express there 1000 middlewares available.

What is middleware?

a function which has three parameters -  req,response,next

Types of middlewares

1.custom middlewares
3.built in middlewares
4.third party middlewares


Types of middlewares based on location(where we declare)

1.app middleware/ global middleware
2.route specfic middlewares
3.url specific middlewares-  either app /route

what middlewares will have 

1.execute any biz logic code which is isloated from real request handlers.

2.make changes to the request and response object


middlewares can be chained together in order to achive common functions

eg:


                                next--is reference to move from one m1 to another m2
view--http--request-----|server--m1--m2---m3--requesthandler---response--->



steps:

1.write middleware
2.attach middleware with application --- app.use

To read json values from user without req.on events

bodyParser - middleware


Database connection:

const mongojs = require('mongojs')
//get the database
const db = mongojs('BooksDb')
//get the table
const books = db.collection('books')

class BooksService {
    findAll() {
        return new Promise((resolve, reject) => {
            db.books.find(function (error, docs) {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(docs);
                }
            });
        });

    }
}

module.exports = new BooksService();


//express application
const express = require('express') // returns a function, used to create application object

const TodoController = require('./controllers/todocontroller');
const UserController = require('./controllers/userscontroller')
const BooksController = require('./controllers/bookscontroller');

const bodyParser = require('body-parser')


//create application object
const app = express();

//body parser middleware
app.use(bodyParser.json())


//custom middleware
//i want to show url an method and date of request every time when user requests

app.use(function (req, res, next) {
    console.log(`URL ${req.path} Method ${req.method} ${new Date()}`)
    //call next 
    next();
});



// /api/todos/list : redirect to the TODOS Controller.
app.use('/api/todos', TodoController)
// /api/users/list : redirect to the USERS Controller
app.use('/api/users', UserController)
app.use('/api/books', BooksController)




//rest end points
//home page
app.get('/', (req, res) => {
    res.send('<h1>Evergent REST API Server</h1>')
});


//to start and listen server
app.listen(3000, function () {
    console.log('Express server is ready!!!');
});
////////////////////////////////////////////////////////////////////////////////////////////

How to build express application faster?

express generator;

1.create project layout with common middlewares

2.can be ready for two types of application
 1.rest end point
 2.dynamic web application - like php,springmvc with views,aspx

express and view layer
  -templates - hbs..

Explorations on middlewares

1.logger
2.authentication
3.thrid party integration middleares
etc.........................................
/////////////////////////////////////////////////////////////////////////////////////////

Conculsion

                   ES6-->React--->Redux--->Saga--->Node--->Express

MERN STACK - REACT FULLSTACK ON JS
MEAN STACK -ANGULAR FULLSTACK ON JS

Deployment:

 src
  -Dockerfile
  -docker-compose.yml
    build: .
     
Dockerfile:

FROM node:12

# Create app directory
WORKDIR /usr/src/app

# Install app dependencies
# A wildcard is used to ensure both package.json AND package-lock.json are copied
# where available (npm@5+)
COPY package*.json ./

RUN npm install
# If you are building your code for production
# RUN npm ci --only=production

# Bundle app source
COPY . .

EXPOSE 8080
CMD [ "node", "app.js" ]

docker build -t app:1.0 .

docker-compose up



Apache benchmark------>

Testing:
https://testing-library.com/docs/react-testing-library/example-intro
https://enzymejs.github.io/enzyme/
