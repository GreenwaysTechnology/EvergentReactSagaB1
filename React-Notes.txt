React:

What is react?

react is lib

framework vs lib

framework will give all in one place : one stop solution.
lib solves only one problem.

react is used to build browser based user interface application

Browser based user interface application tech stack

1.html
2.css
3.javascript.

React features

1.declarative lib
2.Model muatation using functional programming principles
3.rerendering cycles using v.dom
4.single/one way data flow


pl can be classified into

1.declarative pl----libs/frameworks
2.imperative pl---libs/frameworks

1.Imperative
   
let customers = [{id:1,name:'a',city:'test'}];

i want find out all customers in chennai city.

function findCustomerByCity(city){
  let result = [];
 for(let i=0;i<customers.length;i++){
    let customer  =customers[i];
   //logic
   if(customer.city === city){
	  result.push(customer);
   }

}
  return result
}

findCustomerByCity('chennai');


2.Declarative

function findCustomerByCity(city){
     return customers.filter(customer=>customer.city == city);
}

findCustomerByCity('chennai');


HTML is more declarative pl.

///////////////////////////////////////////////////////////////////////////////////////////

HTML:

1.HTML IS PL? - YES
2.HTML Is compiled -YES
3.HTML is excuted-YES

java
  -source .java
 -compile -.class -assembly
 -excute -jvm--result


index.html -source code

<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
  |
loader---LOAD Code into browser
 |
   from file: or http:
 |
 parser : parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
|
 HTML Execution engine : Request Os ,to allocate memory :Runtime
|
-LinkedList
body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body
| 
 Linking the Nodes: Tree
body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
Layout/Paint Engine: will convert nodes into pxs : final output
..............................................................................................
In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

that is birth of javascript.

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.



One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.
............................................................................................

How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	
 		  Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.	*******************************************************************************************	

Who and when "H1" object is created?

if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()


<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?



if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()

<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?

Note: For html elements, we cant create object directly, rather than JS Engine will create objects , return references to the developer to access.
 How via factory Objects: object helps to get other documents

Factory Object : HTML Document =>body

document.getElementById();
   |
Implicit object reference variable which points HTMLDocument OBject.

.............................................................................................

What is our objective here? DOM Programming?


Enter into DOM programming:

1.write dom programming using javascript language.

<body>
  |
HTMLDocument : body : factory Object


Document apis:

Finding HTML Elements

HTMLElement document.getElementById(id)	       Find an element by element id


HTMLElement Document document.getElementsByTagName(name)	Find elements by tag name


HTMLElement document.getElementsByClassName(name)	Find elements by class name


HTMLElement document.querySelectory(selector)        find element/elements by selector




Changing HTML Elements : update existing element
......................
element.innerHTML =  new html content	Change the inner HTML of an element
element.attribute = new value	Change the attribute value of an HTML element
element.style.property = new style	Change the style of an HTML element
Method	Description
element.setAttribute(attribute, value)	Change the attribute value of an HTML element

Adding and Deleting Elements

document.createElement(element)	Create an HTML element

document.removeChild(element)	Remove an HTML element

document.appendChild(element)	Add an HTML element

document.replaceChild(new, old)	Replace an HTML element

//document.write(text)	Write into the HTML output stream



Create new Element:

1.create element
2.attach that element on existing tree. appendChild

function findElement() {
      //get the h1
      const element = document.getElementById('heading');
      console.dir(element);
      //get the content
      console.log(element.innerHTML);
}
findElement();

function updateElement() {
      const element = document.getElementById('heading');
      //element.innerText = 'Welcome to React' : Plain String
      element.innerHTML = 'Welcome to React!'; // which is node
}
updateElement()

function createElement() {
      const element = document.createElement('h2');
      element.innerHTML = 'Hey Buddy Are you new to DOM!';
      //attach that element
      document.body.appendChild(element);
}
createElement();

function applyStyle() {
      const element = document.getElementById('heading');
      //css property inside javascript
      element.style.backgroundColor = 'yellow'

}
applyStyle()


User interaction : Event Handling : UI events

Hardware events : mouse,keyboard,touch events
application events : onload,onupdate,offline,online........

How to add user interaction?

Every dom element has ability to subscribe events called dom events.

ways to attach events?

1.inline events
2.through coding

eventattachment has syntax

on+EventName = "callbackfunction /handler function"

Event Object : Object asscioated with every dom element.

 Which is proxy object between dom element and handler function.

if you want to access any dom element inside event handler, event object will help
event object is created and ready for use inside handler function arg.


 <h1 id="heading" onmouseout="applyMouseOut(event)" onmouseover="applyDynamicStyle(event)">Welcome to DOM</h1>

function applyDynamicStyle(e) {
      console.dir(e);
      const element = e.target;
      console.log(element);
      element.style.backgroundColor = 'green'

}

function applyMouseOut(e) {
      const element = e.target;
      element.style.backgroundColor = 'yellow'
}


<h1 id="heading">Welcome to DOM</h1>

function applyDynamicStyle(e) {
      console.dir(e);
      const element = e.target;
      console.log(element);
      element.style.backgroundColor = 'green'

}
function applyMouseOut(e) {
      const element = e.target;
      element.style.backgroundColor = 'yellow'
}

document.getElementById('heading').addEventListener('mouseover', applyDynamicStyle)

document.getElementById('heading').addEventListener('mouseout', applyMouseOut);
//////////////////////////////////////////////////////////////////////////////////////////


javascript language can be used to manipulate web documents.

When we use javascript language directly , we face lot of problems

1.Complexity
2.Performance
3.No standard practice

In 2001,DOM Wrappers - libs /frameworks came into picture.
 DOJO
2005, JQuery
/////////////////////////////////////////////////////////////////////////////////////////////

Architecture tech stack for dom programming


Plain JS
			 Application(dom) -plain js
			     |
			 Javascript Engine
			      |
			  Browser Engine




Framework/lib
			 Application(JQuery)
			     |
		       ---------------------------
			  JQuery Engine	------javascript programming		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine



What is jquery engine?
  Jquery engine is also javascript program.




Angular
			 Application(Angular)
			     |
		       ---------------------------
			  Angular Engine : Renderer(Ng2) Renderer2(Ng4,5),Ivy(6,7)		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine



React


		       Application(React)
			     |
		       ---------------------------
	           React Engine :React fiber-->React 16 on wards		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine



React is created by face book.

React was created not for others but created for face book one of the use case called "Buddylist" / chat application.


instagram web version was fully built by react.

React most implementations

1.flipkart ui is written react.
2.espn cric info
3.facebook use case chat , graph....
4.netflix
etc......

Where we can use React ? What type of application we can build using react.


Data intensive application // Data driven app
 where more data , which are chainging rapidly, where you want to update ui very faster with out ui flickering.


React can be used to build application for 

.........................................
1.browsers : Desktop
2.Mobile Apps : React Native
.......................................................................................


face book is working on many features projects related to react

3.React VR : Virtual Reality.
4.React Car : For car applications
5.React TV  : React for TV.
6.React IOT : any devices

We are going to learn react web for browsers.


React core modules:

react.js      => Core module
react-dom.js  => Browser

-----------------------------------------------------------------------------
 Markup layer             |  React Core Engine    | Render Engine   | Target
-----------------------------------------------------------------------------

HTML Markup---------------|  Object Tree(V.DOM)   |  ReactDom.render |  Browser

Mobile Markup-------------|  Object Tree          |ReactNative.render| Mobile /Tabs

VR Markup---------------  |  Object Tree          |VR.render         |VR devices

IOT Markup--------------- |  Object Tree          | IOT.render       |IOT Devices   


Object Tree :

Note : in js every html element is object, in browser every element is node which forms tree


<div>
   <h1>
       hello
   </h1>
       |
       div
          |
          h1
            hello

         |
         divObject
		|
		H1 Object
			hello


		|
		React engine
		   |
		   
////////////////////////////////////////////////////////////////////////////////////////////

coding :

Task: create dom element, dom elements(tree).........


1.how to create dom objects using vannila js

2.how to create dom objects using react.
	
/////////////////////////////////////////////////////////////////////////////////////////////

React uses declarative dom programing using a mini language invented by facebook : JSX

JSX :
 PL language built by face book to write user interfaces.
 JSX is collection of html markup and javascript.
 JSX is dsl and declarative.
  Every device has its own jsx language syntax.
  Brower jsx can't be used for building mobile application.


Since jsx  is a language cant be executed on browser /mobile directly.



JSX compilation model:

                 layout.js / layout.jsx
		       |
		    compiler - babel.js 
			|
		    plain js code
			|-----------------------Dev cycle
	----------------------------------------- -- Excution cycles Starts
Runtime : React Engine  compiled code feed into react engine
			|
		     Excute compiled js code : function calls
			|
	     create virtual Object tree (in browser V-dom)
		        |
		     Render Engine ; will conver react object tree into js dom object tree
			|
		   Flush the tree into target
			|
	--------------------------------------------
        |
     Browser

//////////////////////////////////////////////////////////////////////////////////////////

JSX is used to create dom elements.

Every DOM element is object.

Component : Component is Object , Coined by MS in 1989.

According to ms, Component is object which has state(date),behaviour(methods) + User interface(Visual).
 eg:Button,TextBox,Grid,Menu,MenuBar,Layout,Table.....

Like Object tree(DOM Tree), In React we can create "Component" Tree.


      Node===DOM Object====Component
       h1     HTMLHeading   Heading
..................................................................................

In coding 

Threre two libs 
1.react.js  => to create component and manages all features related component.
2.react-dom => Render engine.



react.js

1.React
  It top level class which provides all apis to create,delete,update components.


react-dom.js

2.ReactDOM
   It is top level class which provides api to flush the v.dom into real dom.




//React : dom element creation : Object creation: Component creation
import React from 'react';
import ReactDOM from 'react-dom';

//create element/object/component : jsx language.

const Heading = <h1>Hello React!</h1>;

//flush the object /object tree/component/component tree into target: browser

ReactDOM.render(Heading, document.getElementById('root'));


///////////////////////////////////////////////////////////////////////////////////////////

Component Creational Patterns

1.variable pattern
2.function pattern
3.es 6 class pattern




//React : dom element creation : Object creation: Component creation
import React from 'react';
import ReactDOM from 'react-dom';

//component creational patterns

//1.function : es 5 , es 6 arrow

// function HeadingComponent() {
//     //returns ReactElement:Object:Comonent
//     //ReactElement is type of any Component in react
//     return <h1>
//         HelloReact!
//     </h1>;
// }
//arrow :
const HeadingComponent = () => <h1>
    HelloReact!
</h1>;


//flush the object /object tree/component/component tree into target: browser
//imperative function call : not recommended HeadingComponent()
//ReactDOM.render(HeadingComponent(), document.getElementById('root'));

//declarative function call with help of mark up
//ReactDOM.render(<HeadingComponent></HeadingComponent>, document.getElementById('root'));
ReactDOM.render(<HeadingComponent />, document.getElementById('root'));

//React : dom element creation : Object creation: Component creation
import React from 'react';
import ReactDOM from 'react-dom';

//component creational patterns
//es 6 class

class HeadingComponent extends React.Component {

    render() {
        return <h1>Hello React!</h1>
    }
}


ReactDOM.render(<HeadingComponent />, document.getElementById('root'));
/////////////////////////////////////////////////////////////////////////////////////////////


JSX : javascript + XML:


Since HTML parser is weak, but when y write react code, we need consistent code generation.

So that react team, developed compiler follows basic xml rules.

Basic XML  rules:

1.every opened element must be closed
  <h1>Hello</h1>
  <Welcome></Welcome>
 some elements may not have closing tag
  <img /> : image element has no child elements : self closing. 

2. In xml you must have one single root element.
  all elements must be organized under single root element.

 <h1>Welcome to React</h1>
 <p>Path finder</p>

In html what can be root element
 <div>,<span>,all html 5 layout eleements header,footer,section,aside...

//React : JSX Rules
import React from 'react';
import ReactDOM from 'react-dom';

const HeadingComponent = () =>
    <div>
        <h1>EverGent!</h1>
        <p>Welcomes you!</p>
    </div>


ReactDOM.render(<HeadingComponent />, document.getElementById('root'));

/////////////////////////////////////////////////////////////////////////////////////////////

How code gets compiled?

source code:

function Welcome() {
      return <h1>Welcome To React!</h1>;
}
|
babel
|
compiled code
function Welcome() {
  return React.createElement(
    'h1',
    null,
    'Welcome To React!'
  );
}
|
runtime : react engine
function Welcome() {
  return React.createElement(
    'h1',
    null,
    'Welcome To React!'
  );
}
|
//React.createElement
function createElement(args){
   document.createElement(args); // low level api call
}
//////////////////////////////////////////////////////////////////////////////////////////////

Object tree : Component Tree : Component composition:
/////////////////////////////////////////////////////

Use case :1 Layouts
component 
 app
 header
 footer
 main


//React : Component composition

import React from 'react';
import ReactDOM from 'react-dom';


//header component
const HeaderComponent = () => <div>
    <h1>Site Header</h1>
</div>

const BodyComponent = () => <div>
    <p>We recommend using JSX to describe what your UI should look like.
    Each JSX element is just syntactic sugar for calling React.createElement(). You will not typically
    invoke the following methods directly if you are using JSX.
    </p>
</div>

const FooterComponent = () => <div>
    <h1>Site Footer</h1>
</div>

const Application = () => <div>
    <HeaderComponent />
    <BodyComponent />
    <FooterComponent />
</div>

ReactDOM.render(<Application />, document.getElementById('root'));
///////////////////////////////////////////////////////////////////////////////////////////

Modularity : breaking application into folders and files

src
 |
 header
 footer
 body

 index.js -entry point

src
 |
 components
 containers
 util
 reducers
 actions
 actioncreators
 api

 index.js -entry point


components are saved with .jsx extension.
but entry points and main application which is inside src folder should be .js only.
barrel export file also .js only.


*********************************************************************************************

Data binding:

 interploated using {data | expression}

//Component : data binding
import ReactDOM from 'react-dom';
import React from 'react';



function getValue() {
    return 100;
}


//Data binding
//data:primitive(string,number,boolean)
//data : object,array
const DisplayBoardComponent = () => {
    //variables
    let message = "Hai";
    let magicNo = 9000;
    let isEnabled = true;
    //object binding
    let product = {
        id: 1,
        name: 'Phone'
    }
    return <div>
        <h1>Data Binding</h1>
        <h2>String {"Hello"} {message}</h2>
        <h2>Number {10} {magicNo}</h2>
        <h2>Boolean {true ? "Enabled" : "Disabled"} {isEnabled ? "Enabled" : "Disabled"}</h2>
        <h2>Object {product.id} {product.name}</h2>
        <h2>Function {getValue()}</h2>

    </div>
};

ReactDOM.render(<DisplayBoardComponent />, document.getElementById('root'));

//////////////////////////////////////////////////////////////////////////////////////////

functional programming;

React core design based on functional programming.

fp principles react uses

1.pure function and immuablity.


pure:

1.pure function
 
A.function which receives input, return the same =>function never modify the input

 function  display(input){
         return input
  }
 input===>input(as out put)

 impure function;
 function  display(input){
         return input *11
  }
what if i want to change(mutate) the input? can i write the code in pure function ? Yes

B.function which receives input, modifies the input, but dont modifity the original input
  rather than, return new output==>immuablity.

 function  display(input){
         return input(immutable input)
 }

React uses both principle with respect to "Component data".

How to bind data in react component?

In two ways

1.property pattern
    -props pattern
2.state pattern

in react , components are created by calling functions

//pure function
//props=? is literal object
function ProfileComponent(props){

   return <h1>props.propertyName</h1>

}
render(ProfileComponent(data))
render<ProfileComponent/>

props are read only.

props
 basic props

//Component : pure function: property
import ReactDOM from 'react-dom';
import React from 'react';

//pure function
//props = {} default value
//props = {variable:value}
// function ProfileComponent(props) {
//     console.log(props)
//     //props.firstName = 'foo'; pure function cant be modified
//     return <div>
//         <h1>Profile Information</h1>
//         <h2>FirstName {props.firstName}</h2>
//     </div>
// }
const ProfileComponent = props => <div>
    <h1>Profile Information</h1>
    <h2>FirstName {props.firstName}</h2>
</div>


//ReactDOM.render(ProfileComponent(input), document.getElementById('root'));
ReactDOM.render(<ProfileComponent firstName="Subramanian" />, document.getElementById('root'));

//////////////////////////////////////////////////////////////////////////////////////////////

props values:

//Component : property values
import ReactDOM from 'react-dom';
import React from 'react';

const ProfileComponent = props => <div>
    <h1>Profile Information</h1>
    <h2>FirstName {props.firstName}</h2>
    <h2>Last Name {props.lastName}</h2>
    <h2>City {props.city}</h2>
    <h2>State {props.state}</h2>
    <h2>Active {props.active ? 'Active' : 'Not Active'}</h2>
    <h2>Likes {props.likes}</h2>
    <h2>Contact {props.contact.email} {props.contact.phone}</h2>
</div>


//propertyName=value
/**
 * property value can be hardcoded
 * property value can be an variable
 */

const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 1000;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

ReactDOM.render(<ProfileComponent
    firstName="Subramanian"
    lastName={lastName}
    city={city}
    state={state}
    active={active}
    likes={likes}
    contact={contact}
/>,

    document.getElementById('root'));


code refactoring:
//Component : property values
import ReactDOM from 'react-dom';
import React from 'react';



//object destructuring
// const ProfileComponent = props => {
//     const { firstName, lastName, city, state, active, likes, contact: { email, phone } } = props;
//     return <div>
//         <h1>Profile Information</h1>
//         <h2>FirstName {firstName}</h2>
//         <h2>Last Name .lastName}</h2>
//         <h2>City {city}</h2>
//         <h2>State {state}</h2>
//         <h2>Active {active ? 'Active' : 'Not Active'}</h2>
//         <h2>Likes {likes}</h2>
//         <h2>Contact {email} {phone}</h2>
//     </div>
// }
const ProfileComponent = ({ firstName, lastName, city, state, active, likes, contact: { email, phone } }) => <div>
    <h1>Profile Information</h1>
    <h2>FirstName {firstName}</h2>
    <h2>Last Name .lastName}</h2>
    <h2>City {city}</h2>
    <h2>State {state}</h2>
    <h2>Active {active ? 'Active' : 'Not Active'}</h2>
    <h2>Likes {likes}</h2>
    <h2>Contact {email} {phone}</h2>
</div>


const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 1000;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

ReactDOM.render(<ProfileComponent
    firstName="Subramanian"
    lastName={lastName}
    city={city}
    state={state}
    active={active}
    likes={likes}
    contact={contact}
/>,

    document.getElementById('root'));

/////////////////////////////////////////////////////////////////////////////////////////////

class and props

props are not passed as a parameter like functions.

in classes props is variable which is derived React.Component

Component class:
...............
Component is super class of a component which has

1.instance variables
props
state
2.instance methods
3.static variables


//Component : props and classes
import ReactDOM from 'react-dom';
import React from 'react';



// class ProfileComponent extends React.Component {
//     render() {
//         console.log(this.props) //by default value is empty object = 
//         return <div>
//             <h1>Profile Information</h1>
//             <h2>FirstName {this.props.firstName}</h2>
//             <h2>Last Name {this.props.lastName}</h2>
//             <h2>City {this.props.city}</h2>
//             <h2>State {this.props.state}</h2>
//             <h2>Active {this.props.active ? 'Active' : 'Not Active'}</h2>
//             <h2>Likes {this.props.likes}</h2>
//             <h2>Contact {this.props.contact.email} {this.props.contact.phone}</h2>
//         </div>
//     }
// }
class ProfileComponent extends React.Component {
    render() {
        const { firstName, lastName, city, state, active, likes, contact: { email, phone } } = this.props;
        return <div>
            <h1>Profile Information</h1>
            <h2>FirstName {firstName}</h2>
            <h2>Last Name {lastName}</h2>
            <h2>City {city}</h2>
            <h2>State {state}</h2>
            <h2>Active {active ? 'Active' : 'Not Active'}</h2>
            <h2>Likes {likes}</h2>
            <h2>Contact {email} {phone}</h2>
        </div>
    }
}

const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 1000;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

ReactDOM.render(<ProfileComponent
    firstName="Subramanian"
    lastName={lastName}
    city={city}
    state={state}
    active={active}
    likes={likes}
    contact={contact}
/>,

    document.getElementById('root'));

//////////////////////////////////////////////////////////////////////////////////////////////


//default Args
function add(a=1,b=1){
  return a+b
}
add(1,2)
add()==


//Component : props  with default props
import ReactDOM from 'react-dom';
import React from 'react';

// class ProfileComponent extends React.Component {
//     //defaultProps : inside class
//     static defaultProps = {
//         firstName: 'defaultName'
//     }

//     render() {
//         const { firstName, lastName, city, state, active, likes, contact: { email, phone } } = this.props;
//         return <div>
//             <h1>Profile Information</h1>
//             <h2>FirstName {firstName}</h2>
//             <h2>Last Name {lastName}</h2>
//             <h2>City {city}</h2>
//             <h2>State {state}</h2>
//             <h2>Active {active ? 'Active' : 'Not Active'}</h2>
//             <h2>Likes {likes}</h2>
//             <h2>Contact {email} {phone}</h2>
//         </div>
//     }
// }
//default Props : outside class
// ProfileComponent.defaultProps = {
//     firstName: 'defaultName'
// }

//default Props with functions

const ProfileComponent = ({ firstName, lastName, city, state, active, likes, contact: { email, phone } }) => <div>
    <h1>Profile Information</h1>
    <h2>FirstName {firstName}</h2>
    <h2>Last Name .lastName}</h2>
    <h2>City {city}</h2>
    <h2>State {state}</h2>
    <h2>Active {active ? 'Active' : 'Not Active'}</h2>
    <h2>Likes {likes}</h2>
    <h2>Contact {email} {phone}</h2>
</div>;

//default Props
ProfileComponent.defaultProps = {
    firstName: 'defaultName'
}


const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 1000;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

ReactDOM.render(<ProfileComponent
    lastName={lastName}
    city={city}
    state={state}
    active={active}
    likes={likes}
    contact={contact}
/>,

    document.getElementById('root'));

////////////////////////////////////////////////////////////////////////////////////////////

property constraints:


what if i want to enforce type rules and validations on property

eg:

 i have property called likes, which is expected to be number, what if i pass string, 
we need to test it.

property constraints will throw warning during dev cycles, if you see warning you have to fix it.

how to apply property type and validation:

ReactComponent has static property "propTypes"

Component.propTypes = { 
 
  id:rule

}
how to tell rules?
 rules are mentioned in a separate module


//Component : typechecking with Props
import ReactDOM from 'react-dom';
import React from 'react';
import PropTypes from 'prop-types';


const ProfileComponent = ({ firstName, lastName, city, state, active, likes, contact: { email, phone } }) => <div>
    <h1>Profile Information</h1>
    <h2>FirstName {firstName}</h2>
    <h2>Last Name {lastName}</h2>
    <h2>City {city}</h2>
    <h2>State {state}</h2>
    <h2>Active {active ? 'Active' : 'Not Active'}</h2>
    <h2>Likes {likes}</h2>
    <h2>Contact {email} {phone}</h2>
</div>;
//define property rules
ProfileComponent.propTypes = {
    firstName: PropTypes.string.isRequired,
    likes: PropTypes.number
}
//default Props
ProfileComponent.defaultProps = {
    firstName: 'defaultName'
}

const firstName = "Subramanian"
const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 100;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

ReactDOM.render(<ProfileComponent
    firstName={firstName}
    lastName={lastName}
    city={city}
    state={state}
    active={active}
    likes={likes}
    contact={contact}
/>,

    document.getElementById('root'));


//Component : typechecking with Props
import ReactDOM from 'react-dom';
import React from 'react';
import PropTypes from 'prop-types';


const ProfileComponent = ({ firstName, lastName, city, state, active, likes, contact: { email, phone } }) => <div>
    <h1>Profile Information</h1>
    <h2>FirstName {firstName}</h2>
    <h2>Last Name {lastName}</h2>
    <h2>City {city}</h2>
    <h2>State {state}</h2>
    <h2>Active {active ? 'Active' : 'Not Active'}</h2>
    <h2>Likes {likes}</h2>
    <h2>Contact {email} {phone}</h2>
</div>;
//define property rules
ProfileComponent.propTypes = {
    firstName: PropTypes.string.isRequired,
    likes: PropTypes.number
}
//default Props
ProfileComponent.defaultProps = {
    firstName: 'defaultName'
}

const firstName = "Subramanian"
const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 100;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

ReactDOM.render(<ProfileComponent
    firstName={firstName}
    lastName={lastName}
    city={city}
    state={state}
    active={active}
    likes={likes}
    contact={contact}
/>,

    document.getElementById('root'));

//////////////////////////////////////////////////////////////////////////////////////////

Arrays and React:

arrays api:
 iterator
  for... --
  for...each -- mutable apis
  map - pure function : returns new array
  filter
  reduce
 ..........

based on array we can build lot of layouts

1.listview -ul .. li
2.cardview - div,header,footer...
3.gridview -table tr


//Arrays
import ReactDOM from 'react-dom';
import React from 'react';
import TODOS from './mock-data/todos-mock';

const ToDoListComponent = props => {
    const { todos } = props;
    return <div>
        <div>
            {
              todos.map(todo => <div>
                    <h3>{todo.title} : {todo.completed ? 'Completed' : 'Not Completed'} </h3>
                </div>)
            }
        </div>
    </div>
}
ReactDOM.render(<ToDoListComponent todos={TODOS} />, document.getElementById('root'));

Styling React Components:

How to add css?

two ways:

using class attribute : external style.
using style attribute : inline

html syntax:
<div class="container">

</div>

React uses jsx syntax

Rule for html attributes

3. html attributes must be in in camel case

HTML ATTRIBUTES

accept acceptCharset accessKey action allowFullScreen alt async autoComplete
autoFocus autoPlay capture cellPadding cellSpacing challenge charSet checked
cite classID className colSpan cols content contentEditable contextMenu controls
controlsList coords crossOrigin data dateTime default defer dir disabled
download draggable encType form formAction formEncType formMethod formNoValidate
formTarget frameBorder headers height hidden high href hrefLang htmlFor
httpEquiv icon id inputMode integrity is keyParams keyType kind label lang list
loop low manifest marginHeight marginWidth max maxLength media mediaGroup method
min minLength multiple muted name noValidate nonce open optimum pattern
placeholder poster preload profile radioGroup readOnly rel required reversed
role rowSpan rows sandbox scope scoped scrolling seamless selected shape size
sizes span spellCheck src srcDoc srcLang srcSet start step style summary
tabIndex target title type useMap value width wmode wrap

how to link css in react?

import css files inside index.js

can we import css?
yes, this is the concept of webpack.

you can import any thing - css,image,documents(static assets)

import './App.css';
import 'bootstrap/dist/css/bootstrap.css'



//Arrays
import ReactDOM from 'react-dom';
import React from 'react';
import TODOS from './mock-data/todos-mock';
// import './index.css'
// import './App.css';
import 'bootstrap/dist/css/bootstrap.css'

//style object :javascript style object pattern
const todoStyle = {
    fontStyle: 'italic',
    color: 'blue'
}

const ToDoListComponent = props => {
    const { todos } = props;
    return <div className="container">
        <div>
            <h1>Todo Application</h1>
            {
                todos.map((todo, index) => <div key={index}>
                    <h3 style={todoStyle}>{todo.title} : {todo.completed ? 'Completed' : 'Not Completed'} </h3>
                </div>)
            }
        </div>
    </div>
}
ReactDOM.render(<ToDoListComponent todos={TODOS} />, document.getElementById('root'));

********************************************************************************************

Component compostion and Uni directional data flow:
...................................................

Flux : 
 It is design pattern, pass data from one component to component uni directional way.


Component Communication;
  how components are going to communicate each other.
  during communication you can pass data.

1.parent to child
   via properties.    
2.child to parent
   
3.siblings : across

How to break the component , why?

Component responsiability:

Component receives data from outside(api,other data sources),the same component is used
to display data. => We should not do this.
 Break component defines roles

1.Container Component
    container component is component which receives data from data sources.
2.Presentational component
    Presentational component is component which receives data from the parent component
 and display the data.
  



Profile => receive properties and display there itself.
 Profile component must receive property then it has to forword properties to another component to display.

  Profile- props--------------getData
    |
   forward props to child component
      |
      ProfileDisplay.
     	|
        Address
	 |
	 ....


import ReactDOM from 'react-dom';
import React from 'react';
import PropTypes from 'prop-types';
import 'bootstrap/dist/css/bootstrap.css'

//break the component
const ProfileContainerComponent = props => {
    return <ProfileDisplayComponent
        firstName={props.firstName}
        lastName={props.lastName}
        city={props.city}
        state={props.state}
        active={props.active}
        likes={props.likes}
        contact={props.contact}
    />
}
//the presentational component
const ProfileDisplayComponent = props => {
    const { firstName, lastName, city, state, active, likes, contact: { email, phone } } = props; return <div>
        <h1>Profile Information</h1>
        <h2>FirstName {firstName}</h2>
        <h2>Last Name {lastName}</h2>
        <h2>Active {active ? 'Active' : 'Not Active'}</h2>
        <h2>Likes {likes}</h2>
        <AddressComponent city={city} state={state} email={email} phone={phone} />
    </div>
}
//sub presentational compoent
const AddressComponent = props => {
    const { city, state, email, phone } = props;
    return <div>
        <addr>
            <p>city {city}</p>
            <p>state {state}</p>
            <p>Phone {phone}</p>
            <p>email {email}</p>
        </addr>
    </div>
}


//data source
const firstName = "Subramanian"
const lastName = 'Murugan';
const city = "Coimbatore";
const state = "Tamil nadu";
const active = true;
const likes = 100;
const contact = {
    email: 'admin@foo.com',
    phone: '9003706368'
}

const Application = () =>
    <div className="container">
        <ProfileContainerComponent
            firstName={firstName}
            lastName={lastName}
            city={city}
            state={state}
            active={active}
            likes={likes}
            contact={contact}
        />
    </div>

ReactDOM.render(<Application />, document.getElementById('root'));


import React, { Component, Fragment } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'


export class Profile extends Component {
      render() {
            return <div className="container">
                  <ProfileDisplay title={this.props.title} name={this.props.name} rating={this.props.rating} status={this.props.status} address={this.props.address} />
            </div>
      }
}


Spread Operator which simplifies property passing from parent to child

  ... : Spread Operator (ES 7 feature) : merge operator
  ... : Rest operator : (ES 6 feature) : passing args 


Syntax:

Old Style:
<ProfileDisplay title={this.props.title} name={this.props.name} rating={this.props.rating} status={this.props.status} address={this.props.address} />

With Spread Notation
<ProfileDisplay {...this.props} />


//how to pass data from the parent compoent to child component in simple way
// how to throw the entire property to child compoents

import ReactDOM from 'react-dom';
import React from 'react';
import PropTypes from 'prop-types';
import 'bootstrap/dist/css/bootstrap.css'
import PROFILES from './mock-data/profile-mock';

//break the component
const ProfileContainerComponent = props => {
    return <ProfileDisplayComponent {...props} title="Profile Information" />
}
//the presentational component
const ProfileDisplayComponent = props => {
    const { id, title, firstName, lastName, active, likes } = props;
    return <div>
        <h1>{title}</h1>
        <h2>Id {id}</h2>
        <h2>FirstName {firstName}</h2>
        <h2>Last Name {lastName}</h2>
        <h2>Active {active ? 'Active' : 'Not Active'}</h2>
        <h2>Likes {likes}</h2>
        <AddressComponent {...props} />
    </div>
}
//sub presentational compoent
const AddressComponent = props => {
    const { city, state, contact: { phone, email } } = props;
    return <div>
        <address>
            <p>city {city}</p>
            <p>state {state}</p>
            <p>Phone {phone}</p>
            <p>email {email}</p>
        </address>
    </div>
}


//data source



const Application = () =>
    <div className="container">

        {
            PROFILES.map((profile, index) => {
                // const { id, firstName, lastName, city, state, active, likes } = profile;
                // return <ProfileContainerComponent
                //     id={id}
                //     firstName={firstName}
                //     lastName={lastName}
                //     city={city}
                //     state={state}
                //     active={active}
                //     likes={likes}
                //     contact={profile.contact}
                // />
                return <ProfileContainerComponent key={index} {...profile} />
            })
        }



    </div>

ReactDOM.render(<Application />, document.getElementById('root'));

////////////////////////////////////////////////////////////////////////////////////////////

state :

state is another way of representing data inside component.

Points:

1.with respect to props, component never modifies data / component never mutates the data.
  -Based on fp principle called "pure function".

2.what if i want to change data /mutate data?
 props never help us, then we need to new pattern , that is called state.

state helps to modifiy data/ mutate data.
 
Pure function:
..............

B.function which receives input, modifies the input, but dont modifity the original input
  rather than, return new output==>immuablity.

 function  display(input){
         return input(immutable input)
 }

how to implement?

1.inside class component we have to write code.

What is the value of props?
  it is literal object
props = {
  title:....
}
value is already initialzed

What is the value of state?

the value of state also must be literal object
The developer must initalize.


How to change state?

Ways :

1.inital render : when page is loaded first
2.through user/program interaction : event handling

Event Handling:

Button==>event====>Listener(callback)

4.1.How to bind event
 <button onclick="listner">text</button> -js

React event binding:you are writing jsx : jsx event binding.
jsx and attribute binding: camelCase
event handler is function/method of class.


 <button className="btn btn-success" onClick={this.increment} >+</button> -external event listner
 <button className="btn btn-success" onClick={()=>{}} >+</button> -inline event listener


write biz logic to mutate the state variable called counter?



render cycle and virtual dom;
.............................

Click-----onIncrement-----render---????no update in the screen.

what is render method ?how it is working ?

render method is method which is called by react engine internally. we should not call manually.

render method returns "Object" ==>ReactElement===>Virtual Object=>Real dom representation inside react engine.

render method returns Object==> dom element with "data-state".

every dom programing we change data eg
  <h1>data</h1> --if you triger any event, js will change data .
 how change works?
  -by removing old value and add new value
    
 <h1>data-1</h1> -> <h1>data-2</h1>

instead of changing the dom mutations(changes) in the orginal dom, react changes in the 
virtual layer, render engine will decide when to update/flush the modified data to underneeth
dom.


how decision is made to flush the modified data?

 React uses algorthim ; diff algorthim

User click---biz logic----->render----returns virtual object(vdom)|---->react takes the snap
shoot of already render dom as object--apply diff algorthim---flushes only modified data to underneeth dom.

how to invoke render cycle?

1.by calling setState method

2.when you pass new props to child components

setState is pure function which modifies data
newObject means immutable object.

setState(function(){return newObject});




1.To return immutable state, pure function pattern

setState(func(oldstate){
   return newState
}) =>new State

State Transition:

Level-1--->Level-2--->Level-3--->Level-4--->Level-5--->LevelN...
 {count:0}---> {count:1}---> {count:2}----->{count:3}--->{count:4}-----> {count:N }

how to return newState?

1. returning new Object with modified data, copy old fields as it is

 let count = prevState.count + 1
 return {
    
    count : count

 }




import ReactDOM from 'react-dom';
import React from 'react';
import PropTypes from 'prop-types';
import 'bootstrap/dist/css/bootstrap.css'


class CounterComponent extends React.Component {

    state = {
        counter: 0 // inital value
    };

    //Listener method
    onIncrement = () => {
        // alert('increment is called')
        //biz logic: increment counter
        // this.state.counter = this.state.counter + 1;
        //console.log(this.state.counter)
        //call render in each button click
        // this.render(); : dont call render manually
        //call setState method
        // this.setState(function (oldstate) {
        //     console.log(oldstate);
        //     //return new object :state object
        //     return {
        //         counter: oldstate.counter + 1
        //     }
        // });
        // this.setState(oldstate => {
        //     return {
        //         counter: oldstate.counter + 1
        //     }
        // });
        // this.setState(oldstate => {
        //     let counter = oldstate.counter + 1;
        //     return {
        //         counter: counter
        //     }
        // }); 
        // this.setState(oldstate => {
        //     let counter = oldstate.counter + 1;
        //     return {
        //         counter
        //     }
        // });

        let counter = this.state.counter + 1;
        this.setState({ counter });
    }

    render() {
        console.log('render method is called', this.state.counter);
        return <div className="container">
            <h1>Counter Application</h1>
            <h3>Counter : {this.state.counter}</h3>
            <button className="btn btn-success" onClick={this.onIncrement}>+</button>
        </div>
    }
}
const Application = () => <CounterComponent />

ReactDOM.render(<Application />, document.getElementById('root'));


Event Handlers:
...............
1.with event listeners
 <button className="btn btn-success" onClick={this.onIncrement}>+</button>


2.with in line event handlers
 <button className="btn btn-success" onClick={
                () => {
                    let counter = this.state.counter - 1;
                    this.setState({ counter });
                }
            }>-</button>

/////////////////////////////////////////////////////////////////////////////////////////
how to add more state variable?




    import ReactDOM from 'react-dom';
    import React from 'react';
    import PropTypes from 'prop-types';
    import 'bootstrap/dist/css/bootstrap.css'


    class ReviewComponent extends React.Component {

        state = {
            like: 0,
            dislike: 0
        };

        //Listener method
        onLike = () => {
            this.setState(function (prvState) {
                console.log('previous state ', prvState)
                //immutabilty logic: we never modifify state directly
                let like = prvState.like + 1
                let dislike = prvState.dislike;
                return {
                    like,
                    dislike
                }
            });
        }
        onDislike = () => {
            this.setState(function (prvState) {
                console.log('previous state ', prvState)
                //immutabilty logic: we never modifify state directly
                let like = prvState.like
                let dislike = prvState.dislike + 1;
                return {
                    like,
                    dislike
                }
            });
        }


        render() {
            console.log('Current State', this.state);
            return <div className="container">
                <h1>Review Application</h1>
                <h3>Like : {this.state.like} </h3>
                <h3>DisLike : {this.state.dislike} </h3>

                <button className="btn btn-success" onClick={this.onLike}>Like</button>
                <button className="btn btn-success" onClick={this.onDislike}>DisLike</button>

            </div>
        }
    }
    const Application = () => <ReviewComponent />

    ReactDOM.render(<Application />, document.getElementById('root'));

////////////////////////////////////////////////////////////////////////////////////////////
How to implement immutablity?

immuablity can be applied on literal object and arrays.

Pure function 2nd principle:
...........................

javascript has api, will never modify object directly, rather it will take copy ,modifies and return the same.

ways of wirting immutablity:

1.plain javascript:

function updateProfile(city, profile) {
    console.log('Previous Profile', profile);
    //way 1; return plain new object
    //create new object, by copying old object properties,
    //while copying , change the property which you want to update
    return {
        id: profile.id, // no change
        name: profile.name,
        city: city
    }

}

drawbacks of this approach:

1.you have to manually copy all the properties.
2.if you want update more properties also complex.

Solution:
1.Object.assign:

function updateProfile(city, profile) {
    console.log('Previous Profile', profile);
    //way 2; Object.assign api
    // return Object.assign({}, profile, { city: city })
    return Object.assign({}, profile, { city })

}

even we can simplify this code using es7 spread operator(...)

//immutablity testing


//whether this function is pure or not
//pure function means never modifes data,if want , then you have to return immutable
//data structure. : dont mutate original object.

//this function not pure function , because it modifies same memory address
// function updateProfile(city, profile) {
//     console.log('Previous Profile', profile);
//     //update logic : mutable or immutable ? 
//     profile.city = city;
//     //return profile after update
//     return profile;
// }

//pure function :
/**
 * 
 * 
 *  
 */
//plain pattern
// function updateProfile(city, profile) {
//     console.log('Previous Profile', profile);
//     //way 1; return plain new object
//     //create new object, by copying old object properties,
//     //while copying , change the property which you want to update
//     return {
//         id: profile.id, // no change
//         name: profile.name,
//         city: city
//     }

// }

// function updateProfile(city, profile) {
//     console.log('Previous Profile', profile);
//     //way 2; Object.assign api
//     // return Object.assign({}, profile, { city: city })
//     return Object.assign({}, profile, { city })

// }
//using spread operator
function updateProfile(city, profile) {
    console.log('Previous Profile', profile);
    //way 3; spread operator (...)
    // return { ...profile, city: city }
    return { ...profile, city }

}
//send profile object for modification
let profile = {
    id: 1,
    name: 'Subramanian',
    city: 'Chennai'
}

//req, i want to update profile city 

//how to test pure function?
//we have javascript api
Object.freeze(profile);
let updatedProfile = updateProfile('Coimbatore', profile);
console.log('Current Profile ', updatedProfile);

////////////////////////////////////////////////////////////////////////////////////////////

import ReactDOM from 'react-dom';
import React from 'react';
import PropTypes from 'prop-types';
import 'bootstrap/dist/css/bootstrap.css'


class ReviewComponent extends React.Component {

    state = {
        like: 0,
        dislike: 0
    };

    //Listener method
    onLike = () => {
        this.setState(prvState => {
            console.log('previous state ', prvState)
            //immutabilty logic: we never modifify state directly
            let like = prvState.like + 1
            //  let dislike = prvState.dislike;
            //way 1: plain js
            // return {
            //     like,
            //     dislike
            // }
            //way 2: using Object.assign
            // return Object.assign({}, prvState, { like })
            //way 3 Using spread notation
            return {
                ...prvState, like
            }
        });
    }
    onDislike = () => {
        this.setState(prvState => {
            console.log('previous state ', prvState)
            //immutabilty logic: we never modifify state directly
            let dislike = prvState.dislike + 1;
            //way 1: plain js
            // return {
            // return {
            //     like,
            //     dislike
            // }
            //return Object.assign({}, prvState, { dislike })
            return {
                ...prvState, dislike
            }

        });
    }


    render() {
        console.log('Current State', this.state);
        return <div className="container">
            <h1>Review Application</h1>
            <h3>Like : {this.state.like} </h3>
            <h3>DisLike : {this.state.dislike} </h3>

            <button className="btn btn-success" onClick={this.onLike}>Like</button>
            <button className="btn btn-success" onClick={this.onDislike}>DisLike</button>

        </div>
    }
}
const Application = () => <ReviewComponent />

ReactDOM.render(<Application />, document.getElementById('root'));
/////////////////////////////////////////////////////////////////////////////////////////////

Arrays and immutablity:



//array immutablity


//add new elements
// function addItem(item, list) {
//     console.log('Before add', list);
//     return list.push(item);
// }

//immuability ;
// function addItem(item, list) {
//     console.log('Before add', list);
//     return list.concat(item);
// }
function addItem(item, list) {
    console.log('Before add', list);
    return [...list, item];
}

let list = [1, 2, 3];
//add new item : push : is pure or not
Object.freeze(list);
let result = addItem(4, list);
//console.log('After add', list);

console.log(result);

// if update,delete,filter:

//array immutable apis
/**
 * 1.map => new array after transformation
 * 2.filter =>new array : update and delete,search or find new element.
 * 
 */
function searchByCity(city, profiles) {
    return profiles.filter(profile => profile.city === city);
}

let profiles = [
    {
        id: 1,
        city: 'coimbatore'
    },
    {
        id: 2,
        city: 'coimbatore'
    },
    {
        id: 3,
        city: 'chennai'
    },
    {
        id: 4,
        city: 'delhi'
    },
    {
        id: 5,
        city: 'pune'
    }
]
const filteredProfiles = searchByCity('pune', profiles);
console.log(filteredProfiles);

//////////////////////////////////////////////////////////////////////////////////////////////
Dynamic props , function as prop:
.......................................

State of an component can be passed as prop to another component (child components)
The listener of component can be passed as prop to another component(child components)


//state as prop

import ReactDOM from 'react-dom';
import React from 'react';
import 'bootstrap/dist/css/bootstrap.css'

//container component
class ReviewComponent extends React.Component {

    state = {
        like: 0,
        dislike: 0
    };

    //Listener method
    onLike = () => {
        this.setState(prvState => {
            console.log('previous state ', prvState)
            //immutabilty logic: we never modifify state directly
            let like = prvState.like + 1
            return {
                ...prvState, like
            }
        });
    }
    onDislike = () => {
        this.setState(prvState => {
            console.log('previous state ', prvState)
            //immutabilty logic: we never modifify state directly
            let dislike = prvState.dislike + 1;

            return {
                ...prvState, dislike
            }

        });
    }


    render() {
        return <div className="container">
            {/**state as prop: dynamic props */}
            <ReviewDisplay {...this.state} onLike={this.onLike} onDislike={this.onDislike} />
        </div>
    }
}

//presentational component : prop dynamically
const ReviewDisplay = props => {
    return <div>
        <h1>Review Application</h1>
        <h3>Like : {props.like} </h3>
        <h3>DisLike : {props.dislike} </h3>
        <button className="btn btn-success" onClick={props.onLike}>Like</button>
        <button className="btn btn-success" onClick={props.onDislike}>DisLike</button>
    </div>
}

const Application = () => <ReviewComponent />

ReactDOM.render(<Application />, document.getElementById('root'));
/////////////////////////////////////////////////////////////////////////////////////////////

What can be a prop to a component:

data as prop
state as prop
function as prop
component as prop
dom elements as prop



<ReviewComponent/> => meaning this this component has no child elements

<div>
 <h1> child </h1>
</div>
<img src='path' />

<ReviewComponent/>  : Component / any dom element as prop

//state as prop

import ReactDOM from 'react-dom';
import React from 'react';
import 'bootstrap/dist/css/bootstrap.css'
import logo from './logo.svg';


//component as prop
class Panel extends React.Component {
    render() {
        return <div className="container">
            {
                this.props.children
            }
        </div>
    }
}

const ImageComponent = () => <img src={logo} />

const Application = () => {
    return <Panel>
        <h1>Panel</h1>
        <ImageComponent />
    </Panel>
}

ReactDOM.render(<Application />, document.getElementById('root'));

///////////////////////////////////////////////////////////////////////////////////////////

Component Life cycle methods:
............................

Parent and child components together

life cycles in general not called by us. where react engine will call.

order of initalization:


Ponit: life cycle api are applied only class components not functional.


Life of Component can be classified into three category.

1.Mount
   Inital component life
  during mount react fires many interal apis called mount life cycle methods
2.Update
   when user/program interacts with component
  during Update react fires many interal apis called Update life cycle methods
3.UnMount
   when component is removed from memory.
 during UnMount react fires a interal apis called UnMount life cycle methods


constructors : not necessary, because it has been simplified.
  used only inital state declartion and initalization.

render : must be used , to create/return virtual dom tree/object tree.

componentDidMount
 it is optional
use cases
1.for doing resource initalization
   like ajax programming,timers,websockets.
2.side effects : imperative js dom Manipulation.


Update: 
update cycle is triggered by three ways

1.if setState is called
2.if forceUpdate is called
4.if cmp receives new props - dynamic


import ReactDOM from 'react-dom';
import React from 'react';
import 'bootstrap/dist/css/bootstrap.css'


class ParentComponent extends React.Component {

    // state = {
    //     like: 0
    // }
    //Mount cycle: inital render phase
    constructor() {
        super();
        this.state = {
            like: 0
        }
        console.log('Parent Constructor is called');
    }
    //after dom is created under javascript
    componentDidMount() {
        console.log('Parent componentDidMount is called');
        //side effects
        document.title = 'Evergent-Home'
    }

    componentDidUpdate() {
        console.log('ParentComponent ComponentDidUpdate')
        //side effects
        document.title = 'Evergent-increment'


    }
    componentWillUnmount() {
        //resource clean up
        console.log('componentWillUnmount')
    }
    render() {
        console.log('Parent render is called')
        return <div>
            <h1>ParentComponent</h1>
            <button onClick={() => {
                let count = this.state.count + 1;
                this.setState({ count })
            }}>+</button>
            <ChildComponent  {...this.state} />
        </div>
    }

}

class ChildComponent extends React.Component {

    //Mount cycle: inital render phase
    constructor() {
        super();
        console.log('ChildComponent Constructor is called');
    }
    componentDidMount() {
        console.log('ChildComponent componentDidMount is called');
    }
    componentDidUpdate() {
        console.log('ChildComponent ComponentDidUpdate')
    }
    componentWillUnmount() {
        //resource clean up
        console.log('componentWillUnmount')
    }
    render() {
        console.log('ChildComponent render is called')
        return <div>
            <h1>ChildComponent</h1>
        </div>
    }

}


const Application = () => {
    return <div>
        <ParentComponent />
    </div>
}
ReactDOM.render(<Application />, document.getElementById('root'));
/////////////////////////////////////////////////////////////////////////////////////////////

Ajax calls:


ajax apis:
React has no separate ajax apis.

react says you can use any third party ajax libs

1.fetch
2.axios
3.jquery ajax

apis: fake api
jsonplaceholder



mport React, { Component } from 'react';
import { render } from 'react-dom';
import classNames from 'classnames'
import 'bootstrap/dist/css/bootstrap.css'

class Todo extends Component {

      state = {
            error: null,
            isLoaded: false,
            todos: []
      }
      componentDidMount() {
            const todourl = 'https://jsonplaceholder.typicode.com/todos';
            fetch(todourl).then(response => response.json()).then(todos => {
                  this.setState(previousState => {
                        return { ...previousState, todos, isLoaded: true };
                  });

            },
                  error => {
                        this.setState({
                              isLoaded: true,
                              error
                        });
                  }
            );
      }
      showCompletedTodos = () => {
            this.setState(pstate => {
                  let completed = pstate.todos.filter(todo => todo.completed);
                  return {
                        ...pstate,
                        todos: completed
                  }
            });
      }
      render() {

            const { error, isLoaded, todos } = this.state;

            if (error) {
                  return <div>Error: {error.message}</div>;
            } else if (!isLoaded) {
                  return <h1>Loading...</h1>;
            } else {
                  return (
                        <div>
                              <h1>TODO App</h1>
                              <button onClick={this.showCompletedTodos} className="btn btn-success">
                                    Show Completed Todos
                              </button>
                              <button className="btn btn-primary">
                                    Show All dos
                              </button>

                              <hr />
                              <h3>Total todos {this.state.todos.length}</h3>
                              <ul className="list-group">
                                    {todos.map((todo, index) => (
                                          <li className={`list-group-item ${classNames({ 'active': todo.completed })}`} key={index}>
                                                <span className="badge badge-pill badge-primary">
                                                      {todo.id}
                                                </span>
                                                <span>
                                                      {todo.title}
                                                </span>
                                          </li>
                                    ))}
                              </ul>
                        </div>
                  );
            }

      }
}

const App = () => {
      return <div className="container">
            <Todo />
      </div>
}

render(<App />, document.getElementById('root'));



conditional rendering:
......................

if i want to display ui(component) based on some conditions.

if(error) show error component
if(progress) -show progress component
if(dataisavailable - show data component


CSS :
static css : if style is set once, cant be modified
-className
-style
Dynamic styles:

highlighting
 on mouse move, i want to high light
 on mouse leave i want to remove light

 on click , i want to apply some style.

<h1>test</h1> --if i move cursor on h1 , show background color.

how to apply dynamic className value ?

 <h1 className="bg-warning">


threre lib called "classname"
 <li className={`list-group-item ${classNames({ 'active': todo.completed })}`} key={index}>


///////////////////////////////////////////////////////////////////////////////////////////

React 16 features:
.................

In react , so many new features been introduced.

Why react 16?

1.add new power to react eco system
2.simplify code base : easy to use.
3.remove lot of boiler plate code
4.remove unsolvable common usecases.

Fragments
Context
Hooks

code refactoring:
React.Component = Component = import React,{Component} from 'react'
ReactDOM.render  =>render   => import {render} from 'react-dom'

React.Fragment: => Fragement = import React,{Component,Fragment} from 'react'


import React, { Component } from 'react';
import { render } from 'react-dom';



class WelcomeComponent extends Component {
    render() {
        return <div>
            <h1>Welcome Component</h1>
        </div>
    }
}

const App = () => <WelcomeComponent />;

render(<App />, document.getElementById('root'));

/////////////////////////////////////////////////////////////////////////////////////////

How to avoid unncessary root /container elements?
how to avoid jsx parent/root elements?



import React, { Component, Fragment } from 'react';
import { render } from 'react-dom';


const GreetingComponent = () => {

    // return <React.Fragment>
    //     <h1>Welcome</h1>
    //     <h1>How are You</h1>
    // </React.Fragment>
    // return <Fragment>
    //     <h1>Welcome</h1>
    //     <h1>How are You</h1>
    // </Fragment>
    return <>
        <h1>Welcome</h1>
        <h1>How are You</h1>
        <Table />
    </>
}


class Table extends Component {
    render() {
        return (
            <table>
                <tr>
                    <Columns />
                </tr>
            </table>
        );
    }
}
class Columns extends Component {
    render() {
        return (
            <>
                <td>Hello</td>
                <td>World</td>
            </>
        );
    }
}

class WelcomeComponent extends Component {
    render() {
        return <div>
            <GreetingComponent />
        </div>
    }
}

const App = () => <WelcomeComponent />;

render(<App />, document.getElementById('root'));

////////////////////////////////////////////////////////////////////////////////////////////

Context:

Communication patterns:

1.Parent -- Child  : via props

2.Child ---Parent   : passing data from the child via event listner: function as prop.

3.Sibliblings--component to component
 ->Redux
 ->Context

Context:


Data sharing between parent and child component:
  Via props

Note : data must be explicitly passed  to the child components(nested) manually.

What if i want to acess data without passing as prop manually.

 parent
    |  via props
     child
       | via props
        child
       | via props
     child
       | --via props
     child
       | -- via props
      .......


 parent
    |  data------------->
     child              |
       |                |
        child           |
       |                |
     child              |
       |                |
     child              |
       | <---------------      

can you access the data from parent to last child without passing data via props

   Yes! ---Context.

Context:

Objective:
Context provides a way to pass data through the component tree without having to pass props down manually at every level.

>In a typical React application, data is passed top-down (parent to child) via props.

>but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.

When to Use?
>Context is designed to share data that can be considered  for a tree of React components, such as the current   authenticated user, theme, or preferred language. 



React.Context Object Creation


context = {

 Provider: {}
 Consumer: {}
}

const ThemeContext = React.createContext('dark');

ThemeContext.Provider
ThemeContext.Consumer

*******************************************************************************************

Without context , passing props to child components:
....................................................

import React, { Component } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'



//Parent Component

class App extends Component {
    //common theme
    theme = {
        "backgroundColor": "red",
        "color": "white"
    }

    render() {
        return <>
            <h1>Parent Component</h1>
            <ToolBar theme={this.theme} />
        </>
    }
}
//child component 1
function ToolBar(props) {

    return <>
        <ThemedButton theme={props.theme} />
    </>
}
//child component 2

function ThemedButton(props) {
    return <>
        <Button theme={props.theme} />
    </>
}
//child component 3

function Button(props) {
    return <button style={props.theme}>Theme</button>
}

render(<App />, document.getElementById('root'))


///////////////////////////////////////////////////////////////////////////////////////
How to avoid props and how we can access theme from app to button.

Note: React provides lot of built in components

1.React.Fragment


Provider :
  It is object used to pass "data" to child components without passing them

Consumer:
 It is object used to consume "data" which was injected by Parent compoent


import React, { Component } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'


//create Context Object
const ThemeContext = React.createContext('dark')

//Parent Component
class App extends Component {
    //common theme
    theme = {
        "backgroundColor": "red",
        "color": "white"
    }

    render() {
        return <>
            <h1>Parent Component</h1>
            <ThemeContext.Provider value={this.theme}>
                <ToolBar />
            </ThemeContext.Provider>
        </>
    }
}
//child component 1
function ToolBar(props) {

    return <>
        <ThemedButton />
    </>
}
//child component 2

function ThemedButton(props) {
    return <>
        <Button />    </>
}
//child component 3

function Button(props) {

    return <ThemeContext.Consumer>
        {theme => <button style={theme}>Theme</button>}
    </ThemeContext.Consumer>
}

render(<App />, document.getElementById('root'))

///////////////////////////////////////////////////////////////////////////////////////////



import React, { Component } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'


//create Context Object
const { Provider, Consumer } = React.createContext('dark')

//Parent Component
class App extends Component {
    //common theme
    theme = {
        "backgroundColor": "red",
        "color": "white"
    }

    render() {
        return <>
            <h1>Parent Component</h1>
            <Provider value={this.theme}>
                <ToolBar />
            </Provider>
        </>
    }
}
//child component 1
function ToolBar(props) {

    return <>
        <ThemedButton />
    </>
}
//child component 2

function ThemedButton(props) {
    return <>
        <Button />    </>
}
//child component 3

function Button(props) {

    return <Consumer>
        {theme => <button style={theme}>Theme</button>}
    </Consumer>
}

render(<App />, document.getElementById('root'))
/////////////////////////////////////////////////////////////////////////////////////////////

React 16 feature:

method return

render method must return only react Element(Object) before react 16


Return values:

1.null
2.string,number,boolean
3.array
4.jsx
5.React.CreateElement =Element
6.Portal


import React, { Component } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'

//react return values

const Welcome = () => {
    //return <h1>JSX</h1>
    //return null;
    //return "Hello"
    //return true;
    //return 100
    //return [1, 2, 3, 45, 67]
    return React.createElement('h1',null,'Hello')
}

render(<Welcome />, document.getElementById('root'))
//////////////////////////////////////////////////////////////////////////////////////////////

Hooks:
.....
Hook is a special function that lets y "hooks into" react features.


objective of hooks:

1.to eleminate class components as much possible.

2.Resuable application behaviours
  eg:ajax calls

eg Hooks:

1.if i am going to remove class means, how can i handle state inside function components.
  useState hook

"use"+functionName ==>hook Syntax
"useState"
"useContext"
"useEffect"
"useAjax"
"useWebSocket"
 
Use case 1 : write class component, replace this with hooks. inside function component 

//React.useState === > {useState}

state value must be object in class compoent
 state = {
    count:0
  }

in useState hook, you can declare even primitives ==only in source code,but inside hook
 your variables will be wrapped by literal object

 const [counter]=useState(0) ====>useState({counter:0})

setState method  inside hook  you need not use setState convention instead of 
 setVariable  ===>setCounter


//hooks
import ReactDOM from 'react-dom';
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import 'bootstrap/dist/css/bootstrap.css'


//Before hooks :class components

/**
class CounterComponent extends React.Component {

    state = {
        counter: 0 // inital value
    };

    //Listener method
    onIncrement = () => {
        let counter = this.state.counter + 1;
        this.setState({ counter });
    }

    render() {
        console.log('render method is called', this.state.counter);
        return <div className="container">
            <h1>Counter Application</h1>
            <h3>Counter : {this.state.counter}</h3>
            <button className="btn btn-success" onClick={this.onIncrement}>+</button>
        </div>
    }
}
const Application = () => <CounterComponent />

ReactDOM.render(<Application />, document.getElementById('root'));
*/

//Hooks
// function CounterComponent(props) {
//     //hooks
//     const [counter, setCounter] = useState(10)
//     function onDecrement() {
//         setCounter(counter - 1)
//     }
//     return <div className="container">
//         <h1>Counter Application</h1>
//         <h2>Counter : {counter}</h2>
//         {/* <button onClick={() => setCounter(prevState => {
//             console.log(`Previouse State ${prevState}`)
//             return prevState + 1
//         })}> +</button> */}
//         <button onClick={() => setCounter(counter + 1)}>+</button>
//         <button onClick={onDecrement}>-</button>

//     </div>
// }

const CounterComponent = (props) => {
    //hooks
    const { seedValue } = props;
    const [counter, setCounter] = useState(seedValue)

    const onDecrement = () => {
        setCounter(counter - 1)
    }
    return <div className="container">
        <h1>Counter Application</h1>
        <h2>Counter : {counter}</h2>
        {/* <button onClick={() => setCounter(prevState => {
            console.log(`Previouse State ${prevState}`)
            return prevState + 1
        })}> +</button> */}
        <button onClick={() => setCounter(counter + 1)}>+</button>
        <button onClick={onDecrement}>-</button>

    </div>
}

CounterComponent.defaultProps = {
    seedValue: 2
}

const Application = () => <>
    <CounterComponent seedValue={10} />
    <hr></hr>
    <CounterComponent />

</>

ReactDOM.render(<Application />, document.getElementById('root'));
//////////////////////////////////////////////////////////////////////////////////////////////


Adding multiple state variables:
import React, { useState } from 'react';
import { render } from 'react-dom';

function Counter(props) {
      const [incrementValue, setincrementValue] = useState(props.incrementSeed);
      const [decrementValue, setdecrementValue] = useState(props.decrementSeed);
      
      return <div>
            <h1>Counter App</h1>
            <h2>Increment Value : {incrementValue}</h2>
            <h2>Decrement Value : {decrementValue}</h2>

            <button onClick={() => setincrementValue(prevState => {
                  console.log(`Previouse State ${prevState}`)
                  return prevState + 1
            })}>
                  increment
          </button>
            <button onClick={() => setdecrementValue(decrementValue - 1)}>decrement</button>
      </div>
}


render(<Counter incrementSeed={50} decrementSeed={20} />, document.getElementById('root'));

/////////////////////////////////////////////////////////////////////////////////////////

useState with literal Object:

import React, { useState } from 'react';
import { render } from 'react-dom';

//state as literal object

const FeedBack = (props) => {
      const state = { like: 10 };
      const [feedback, setFeedback] = useState(state);
      const increment = () => {
            let like = feedback.like + 1;
            setFeedback({ ...feedback, like });
      };
      return <div>
            <p>Your Feedback {feedback.like}</p>
            <button onClick={increment}>
                  increment
         </button>
      </div>;
};
//////////////////////////////////////////////////////////////////////////////////////////

Side Effects: how did you handle side effects in class components:
  Life cycle methods : componentDidMount, and ComponentDidUpdate

how to the above life cycle methods in the functional component?

we can use hook called useEffect hook 

What is side effects?
 Changing DOM elements after vdom is mounted into real dom, and if you trigger update cycle,vdom is prepared, starts changing the dom layout.

eg: i want to change the browser title of my application based on screen name

Browser title in the inital phase
   -Customer
once if i start doing operations, like add,delete,update,search....
  -Customer-add  / -Customer-delete -Customer-update

if i am adding javascript dom listener,doing some side effects.

 -you need to add listener, and also you need to remove listener.

 window.addEventListener('resize',function(){
    //side effects
 });
 window.removeEventListener('resize',function(){
    //side effects
 });

//Side effects using old react style
class Customer extends Component {


      state = {
            screen: 'Customer Manager App'
      }
      add = () => {
            this.setState({ screen: 'Customer Manager App - Add ' })
      }
      render() {
            return <div>
                  <h1>Customer Manager App: using Side effects</h1>
                  <button onClick={this.add} >Add</button>
            </div>
      }
      //side effeects with inital / mount cycle
      componentDidMount() {
            //imperative dom
            document.title = this.state.screen;
      }
      //side effects with update cycle
      componentDidUpdate() {
            document.title = this.state.screen;
      }
}

render(<Customer />, document.getElementById('root'));

Side Effects,DOM manipulation,Memory Management using functional Components
...........................................................................

useEffect hook : 

 ->useEffect is replacement of componentDidMount and componentDidUpdate


import React, { useState, useEffect } from 'react';
import { render } from 'react-dom';


function Customer(props) {

    const [screen, setScreen] = useState('Customer Manager App');
    //Performing side effects
    useEffect(function () {
        //side effects
        document.title = screen;
    });
    function changeTitle() {
        setScreen('Customer Manager App -Add');
    }
    return <div>
        <h1>Customer Manager App: Function using Side effects</h1>
        <button onClick={changeTitle} >Add</button>

    </div>
}

render(<Customer />, document.getElementById('root'));

//////////////////////////////////////////////////////////////////////////////////////////////

Resoure Handling: how to avoid memory leaks

Where do you write memory clean up activties in old react?

componentWillunMount(){
  window.removeListener('resize');
}

In useEffect hooks:
 return a funciton, inside write a clean up code.

///////////////////////////////////////////////////////////////////////////////////////////




import React, { useState, useEffect } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'

/**
 * 
 * The below is not scalable;
 * the window resize behaviour i want in other component as well then again i have 
 * write code inside : code duplication
 * as app dev, he requires many utilties like window resize...
 * 
 */

function CustomerComponent({ title }) {
    const [screen, setScreen] = useState(title)
    //declare variable to hold currnt window width
    const [width, setWidth] = useState(window.innerWidth);
    //feature using hooks

    //feature using hooks

    //set screen title 
    useEffect(() => {
        //side effects
        document.title = screen;
        //handler function
        const handlerResize = () => setWidth(window.innerWidth)
        window.addEventListener('resize', handlerResize)

        //component will unmount
        return () => {
            window.removeEventListener('resize')
        }

    })
    return <div className="container">
        <h1>Customer Management App</h1>
        <h2>Current Screen Width : {width}</h2>
    </div>
}

const App = () => <CustomerComponent title="Customer Manager App" />

render(<App />, document.getElementById('root'));

/////////////////////////////////////////////////////////////////////////////////////////

Custom Hooks, we can write our own hooks

hooks are just simple javascript function,can be named any but recommend is start with
"use+HookName".

src/hooks/usewindowTitleHook.js

import React, { useEffect } from 'react';
//this hook not returning any value
export const useWindowSetTitle = screen => {
    useEffect(() => {
        //side effects
        document.title = screen;
    })
}

src/hooks/useWindowidthHook.js
import React, { useState, useEffect } from 'react';
//custom hook
//Custom hook may return value or may not
export const useWindowWidth = () => {
    //declare variable to hold currnt window width
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        //handler function
        const handlerResize = () => setWidth(window.innerWidth)
        window.addEventListener('resize', handlerResize)
        //component will unmount
        return () => {
            window.removeEventListener('resize', handlerResize)
        }
    })
    return width;

}

src/hooks/index.js

export { useWindowWidth } from './useWindowWidthHook';
export { useWindowSetTitle } from './useSetWindowTitleHook'



src/index.js
import React, { useState, useEffect } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'
import { useWindowWidth, useWindowSetTitle } from './hooks';

function CustomerComponent({ title }) {
    const [screen, setScreen] = useState(title)
    useWindowSetTitle(screen)    
    return <div className="container">
        <h1>Customer Management App</h1>
        <h2>Current Screen Width : {useWindowWidth()}</h2>
    </div>
}

const App = () => <CustomerComponent title="CMS - Evergent" />

render(<App />, document.getElementById('root'));

/////////////////////////////////////////////////////////////////////////////////////////////

How to use  "useContext"?


import React, { useState, useEffect, useContext } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'
import { useWindowWidth, useWindowSetTitle } from './hooks';

const theme = {
    "backgroundColor": "red",
    "color": "white"
}
export const ThemeContext = React.createContext(theme)


function CustomerComponent({ title }) {
    const [screen, setScreen] = useState(title)
    const theme = useContext(ThemeContext);
    useWindowSetTitle(screen)
    return <div className="container">
        <h1 style={theme}>Customer Management App</h1>
        <h2>Current Screen Width : {useWindowWidth()}</h2>
    </div>
}

const App = () => <CustomerComponent title="CMS - Evergent" />

render(<App />, document.getElementById('root'));
////////////////////////////////////////////////////////////////////////////////////////////

How ajax calls using hooks?



then(fun1,fun2)

import React, { useState, useEffect } from 'react';
import { render } from 'react-dom';

function Users() {
      const [users, setUsers] = useState({
            error: null,
            isLoaded: false,
            items: []
      });
      useEffect(() => {
            const url = `https://jsonplaceholder.typicode.com/users`;
            fetch(url).then(response => response.json())
                  .then(result => {
                    setUsers({ ...users, isLoaded: true, items: result })
                  }, 
                  (error) => {
                 
                        setUsers({ ...users, isLoaded: true, error: error })
                  })
      });
      if (users.error) {
            return <div>Error: {users.error.message}</div>;
      } else if (!users.isLoaded) {
            return <div>Loading...</div>;
      } else {
            return (
                  <ul>
                        {users.items.map((user, index) => (
                              <li key={index}>
                                    {user.username} {user.email}
                              </li>
                        ))}
                  </ul>
            );
      }
}
render(<Users />, document.getElementById('root'));
///////////////////////////////////////////////////////////////////////////////////////////

Form Handling:
.............

1.class based 
2.hooks


FORM input elements
textbox,radio,checkbox,select

how to get value of the these controls inside react component (inside listener function)


HOW TO read/manipulate dom elements using react?

react uses two pattern

1.through event Object
  Event Object is proxy/broker object which is created and attached on to every html element
/dom object.

Javascript Event Object:

 "EventTarget" -Object

since this object is already created, how to get this object into our program.

Js:
<button onclick="sayHello()">

//listener function : type of e is "EventTarget"
function sayHello(e){
    //get button object inside this function 
}

In react, we cant access "EventTarget" directly , because react engine provides one more proxy
SyntheticEvent

SyntheticEvent is object inside react.


Flow
 React listener -----will talk to --->SyntheticEvent ----->EventTarget----DOM


SyntheticEvent Object apis:

boolean bubbles
boolean cancelable
DOMEventTarget currentTarget
boolean defaultPrevented
number eventPhase
boolean isTrusted
DOMEvent nativeEvent
void preventDefault()
boolean isDefaultPrevented()
void stopPropagation()
boolean isPropagationStopped()
void persist()
DOMEventTarget target
number timeStamp
string type



import React, { Component } from 'react';
import { render } from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'


class Form extends Component {

    //select box values
    leaves = ['Sick', 'Medical', 'Causal', 'Earned', 'others'];
    //state : form values
    state = {
        firstName: 'firstname',
        lastName: 'lastname',
        leaveType: this.leaves[0]
    }

    // //textbox1 
    // firstNameHandler = e => {
    //     console.log(e.target.value);

    // }
    // //textbox 2
    // lastNameHandler = e => {
    //     console.log(e.target.value);
    // }
    //listener
    //evt is type of SyntheticEvent
    handleChange = (evt) => {
        //get the text box values
        //which text box value
        //Get control name,input,select box
        const name = evt.target.name;
        //Get control's value
        const value = evt.target.value;
        this.setState({
            [name]: value // [firstName] : 'subramanian' [lastName]='' [leaveType]='MedicalLeave'
        });

    }
    //listener
    onSave = evt => {
        evt.preventDefault(); //will stop submitting form to server automatically.
        alert(JSON.stringify(this.state))
    }

    render() {
        return <div>
            <h1>User Form</h1>
            <h2>{JSON.stringify(this.state)}</h2>
            <form onSubmit={this.onSave}>
                <div className="form-group">
                    <label htmlFor="firstName">First Name</label>
                    <input required onChange={this.handleChange} type="text" className="form-control" id="firstName" placeholder="Enter First name" name="firstName" value={this.state.firstName} />
                </div>
                <div className="form-group">
                    <label htmlFor="lastName">Last Name</label>
                    <input onChange={this.handleChange} type="text" className="form-control" id="lastName" placeholder="Enter last name" name="lastName" value={this.state.lastName} />
                </div>
                <div className="form-group">
                    <label htmlFor="leaveType">Leave Type</label>
                    <select name="leaveType" className="form-control" value={this.state.leaveType} onChange={this.handleChange}>
                        {this.leaves.map((leave, index) => {
                            return <option key={index} value={leave}>{leave}
                            </option>
                        })};
   </select>
                </div>
                <button type="submit" className="btn btn-primary">Submit</button>

            </form>
        </div >
    }
}

const App = () => {
    return <div className="container">
        <Form />
    </div>
}

render(<App />, document.getElementById('root'));
/////////////////////////////////////////////////////////////////////////////////////////////
Forms && Hooks:








2.through ref pattern(reference) : Uncontrolled component












